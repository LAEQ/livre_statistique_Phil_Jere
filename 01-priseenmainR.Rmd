# Prise en main de R

Dans ce chapitre, nous reviendrons brièvement sur l’histoire de ![](images/logos/Rlogo.png) et la philosophie qui entoure le logiciel. Nous donnerons quelques conseils pour son installation et la mise en place d’un environnement de développement. Nous présenterons les principaux objets qui sous-tendent tout le travail effectué avec ![](images/logos/Rlogo.png) (dataframe, vecteur, matrice, etc.) et comment les manipuler avec des exemples appliqués. Enfin, nous terminerons cette section avec un tour d’horizon des capacités graphiques de ![](images/logos/Rlogo.png).

## Histoire et philosophie de ![](images/logos/Rlogo.png){#sect11}

![](images/logos/Rlogo.png) est à la fois un langage de programmation et un logiciel libre (sous la licence publique générale GNU) dédié à l'analyse statistique et supporté par une fondation : _R foundation for Statistical computing_. Il est principalement écrit en C et Fortran.

![](images/logos/Rlogo.png) est l'héritier de S, un autre langage de programmation dédié à l'analyse statistique publié pour la première fois en 1976 et créé par John Chambers pour l'entreprise Nokia (Bell Laboratories). S a donné naissance à S-PLUS (logiciel propriétaire) et à son frère ![](images/logos/Rlogo.png) (logiciel libre). L'idée centrale derrière le développement de S était de faciliter le passage rapide et fidèle de l'idée à l'implémentation [@chambers1998programming]. Cet état d'esprit est encore un des fondements de la philosophie de ![](images/logos/Rlogo.png).

![](images/logos/Rlogo.png) a été créé par Ross Ihaka et Robert Gentleman à l'Université d'Auckland en Nouvelle Zélande. Si vous avez un jour l'occasion de passer dans le coin, une plaque est affichée dans le département de statistique de l'université, ça mérite le détour (figure \@ref(fig:fig01)). Une première version a été publiée en 1996, mais la première version stable ne date que de 2000, il s'agit donc d'un logiciel relativement récent si on le compare à ses concurrents SAS (1976), SPSS (1968) et Stata (1984).

```{r fig01, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Lieu de pélerinage de R",  out.width='60%'}
knitr::include_graphics('images/introduction/plaque.jpg', dpi = NA)
```

![](images/logos/Rlogo.png) a cependant réussi à s'imposer tant dans la milieu de la recherche que dans le secteur privé. Pour s'en convaincre, il suffit de lire l'excellent article concernant [la popularité des logiciels d'analyse de données](http://r4stats.com/articles/popularity/){target="_blank"} tirée du site [r4stats.com](http://r4stats.com){target="_blank"} (figure \@ref(fig:fig02)). 

```{r fig02, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Nombre d'articles trouvés sur Google Scholar (Source : Robert A. Muenchen)",  out.width='50%'}
knitr::include_graphics('images/introduction/r_citations.jpg', dpi = NA)
```

Les nombreux atouts de ![](images/logos/Rlogo.png) justifient largement sa popularité sans cesse croissante : 

* ![](images/logos/Rlogo.png) est un logiciel à code source ouvert (*open source*) et ainsi accessible à tous gratuitement.
* Le développement du langage ![](images/logos/Rlogo.png) est centralisé, mais la communauté peut créer et partager facilement des *packages*. Les nouvelles méthodes sont ainsi rapidement implémentées comparativement aux logiciels propriétaires.
* ![](images/logos/Rlogo.png) est un logiciel multi-plateforme, fonctionnant sur Linux, Unix, Windows et Mac.
* Comparativement à ses concurrents, ![](images/logos/Rlogo.png) dispose d'excellentes solutions pour manipuler des données et réaliser des graphiques.
* ![](images/logos/Rlogo.png) dispose de nombreuses interfaces lui permettant de communiquer, notamment avec des systèmes de bases de données SQL et non SQL (MySQL, PostgresSQL, MongoDB, etc.), à des systèmes de *big data* (Spark, Hadoop), à des systèmes d'information géographique (QGIS, ArcGIS) et même à des services en ligne comme Microsoft Azure ou Amazon AWS.
* ![](images/logos/Rlogo.png) est un langage de programmation à part entière, ce qui lui donne plus de flexibilité que ses concurrents dans le domaine privé (SPSS, SAS, STATA). Avec ![](images/logos/Rlogo.png), vous pouvez accomplir des tâches aussi variées que : monter un site web, créer un robot collectant des données en ligne, effecter des analyses qualitatives, combiner des fichiers PDF, composer des diapositives pour une présentation ou même éditer un livre (comme celui-ci), mais aussi réaliser des analyses statistiques.

Un des principaux attrait de ![](images/logos/Rlogo.png) est la quantité astronomique de *packages* actuellement disponibles. Un *package* est un ensemble de nouvelles fonctionnalités développées par un ou plusieurs utilisateurs de ![](images/logos/Rlogo.png) et mises à disposition de l'ensemble de la communauté. Par exemple, le *package* **ggplot2** est dédié à la réalisation de graphiques; les packages **data.table** et **plyr** permettent de manipuler des tableaux de données; le *package* **car** apporte de nombreux outils pour faciliter l'analyse de modèles de régressions, etc. Ce partage des *packages* rend accessible à tous des méthodes d'analyses complexes et récentes et favorise grandement la reproductibilité de la recherche. Cependant, ce fonctionnement implique quelques désavantages : 

* il existe généralement plusieurs *packages* pour effectuer le même type d'analyse ce qui peut devenir une source de confusion;
* certains *packages* cessent d'être mis à jour au fil des années, ce qui nécessite de leur trouver d'autres alternatives (et ainsi apprendre la syntaxe des nouveaux *packages*);
* il est impératif de s'assurer de la fiabilité des *packages* que vous souhaitez utiliser car n'importe qui peut proposer un *package*.

Il nous semble important de relativiser d'emblée la portée du dernier point. Il est rarement nécessaire de lire et analyser le code source d'un *package* pour s'assurer de sa fiabilité. Nous ne sommes pas des spécialistes de tous les sujets et il peut être extrêmement ardu de comprendre la logique d'un code écrit par quelqu'un d'autre. Nous vous recommandons donc de privilégier l'utilisation de *packages* qui :

* ont fait l'objet d'une publication dans une revue à comité de lecture ou qui ont déjà été cités dans dans des études ayant fait l'objet d'une publication revue par les pairs;
* font partie de projets comme [ROpensci](https://ropensci.github.io/reproducibility-guide/sections/introduction/){target="_blank"} prônant la vérification  par les pairs ou subventionnés par des organisations comme [R Consortium](https://www.r-consortium.org/){target="_blank"}.
* sont disponibles sur l'un des deux principaux répertoires de packages R [CRAN](https://cran.r-project.org/){target="_blank"} ou [Bioconductor](https://www.bioconductor.org/){target="_blank"}.

Toujours pour nuancer notre propos, il convient de distinguer *package* de *package*! Certains d'entre eux sont des ensembles très complexes de fonctions permettant de réaliser des analyses poussées alors que d'autres sont des projets plus modestes dont l'objectif principal est de simplifier le travail des utilisateurs. Ces derniers ressemblent à des petites boites à outils et font généralement moins l'objet d'une vérification intensive.

Pour conclure cette section, l'illustration partagée sur Twitter par Darren L Dahly résume avec humour la force du logiciel ![](images/logos/Rlogo.png) et de sa communauté (\@ref(fig:fig03)) : ![](images/logos/Rlogo.png) apparait clairement comme une communauté hétéroclyte, mais diversifiée et adaptable.

```{r fig03, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Métaphore sur les langages et programmes d'analyse statistique",  out.width='60%'}
knitr::include_graphics('images/introduction/softwares_and_cars.jpeg', dpi = NA)
```

Dans ce livre, nous détaillerons les **packages** utilisés dans chaque section avec un encadré spécifique, accompagné de l'icône suivant : 

```{r fig04, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Icône des encadrés dédiés aux packages",  out.width='20%'}
knitr::include_graphics('css/images/package.png', dpi = NA)
```

## Installation de ![](images/logos/Rlogo.png) et RStudio {#sect12}

La première étape pour travailler avec ![](images/logos/Rlogo.png) est bien sûr de l'installer. Pour ce faire, il suffit de visiter le site web de [CRAN](https://cran.r-project.org/){target="_blank"} et de télécharger la dernière version de ![](images/logos/Rlogo.png) en fonction de votre système d'exploitation : Windows, Linux ou Mac. Une fois installé, si vous démarrez ![](images/logos/Rlogo.png) immédiatement, vous aurez alors accès à une console, plutôt rudimentaire, attendant sagement vos instructions (figure \@ref(fig:fig05)).

```{r fig05, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="La console de base de R",  out.width='85%'}
knitr::include_graphics('images/introduction/r_console.jpeg', dpi = NA)
```

Rares sont les utilisateurs de ![](images/logos/Rlogo.png) qui préfèrent  travailler directement avec la console et écrire leur code dans un fichier séparé en utilisant un éditeur de texte. Par conséquent, nous vous recommandons vivement d'utiliser RStudio, soit un environnement de développement dédié à ![](images/logos/Rlogo.png), offrant une intégration très intéressante d'une console, d'un éditeur de texte, d'une fenêtre de visualisation des données, d'une autre pour les graphiques, d'un accès à la documentation, etc. En d'autres termes, si ![](images/logos/Rlogo.png) est vélo minimaliste, RStudio permet d'y rajouter des freins, des vitesses, un porte-bagage, des gardes boues et une selle confortable. Vous pouvez [télécharger](https://rstudio.com/products/rstudio/download) et installer RStudio sur Windows, Linux et Mac. La version de base est gratuite, mais l'entreprise qui développe ce logiciel propose aussi des versions commerciales du logiciel qui assurent essentiellement un support. Il existe d'autres environnements de développement pour travailler avec ![](images/logos/Rlogo.png) (VisualStudio, Jupyter, Tinn-R, Radiant, RIDE, etc.), mais RStudio offre à ce jour la meilleure option en terme de facilité d'installation, de prise en main et de fonctionnalités proposées (voir l'interface de RStudio à la figure \@ref(fig:fig06)).

```{r fig06, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Environnement de base de RStudio",  out.width='85%'}
knitr::include_graphics('images/introduction/r_studio_01.jpeg', dpi = NA)
```

Avant d'aller plus loin, notez que : 

* la console actuellement ouverte dans RStudio vous informe de la version de ![](images/logos/Rlogo.png) que vous utilisez. Vous pouvez en effet avoir plusieurs versions de ![](images/logos/Rlogo.png) installées sur votre ordinateur et passer de l'une à l'autre avec RStudio. Pour cela, naviguez dans l'onglet *Tools / Global Options* et dans le volet  *General*, vous pouvez sélectionner la version de ![](images/logos/Rlogo.png) que vous souhaitez utiliser.
* L'aspect de RStudio peut être modifié en navigant dans l'onglet *Tools / Global Options* et dans le volet *Appareance*. Nous avons une préférence pour le mode sombre avec le style *pastel on dark*, mais libre à chacun de choisir le style qui lui convient.

```{r fig07, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="RStudio avec le style pastel on dark",  out.width='85%'}
knitr::include_graphics('images/introduction/r_studio_02.jpeg', dpi = NA)
```

Une fois ces détails réglés, vous pouvez ouvrir votre première feuille de code en allant dans l'onglet *File / New File/ R Script*, votre environnement est maintenant découpé en quatre fenêtres (figure \@ref(fig:fig08))</span> : 

1. L'éditeur de code, vous permettant d'écrire le script que vous voulez exécuter et permettant de garder une trace de votre travail. Ce script peut être enregistré sur votre ordinateur avec l'extension **.R**, mais ce n'est qu'un simple fichier texte.
2. La console vous permettant d'exécuter votre code R et de voir les résultats s'afficher au fur et à mesure.
3. La fenêtre d'environnement vous montrant les objets, fonctions et jeux de données actuellement disponibles dans votre session (chargés dans la mémoire vive).
4. La fenêtre de l'aide, des graphiques et de l'explorateur de fichiers. Vous pouvez accéder ici à la documentation de ![](images/logos/Rlogo.png) et des *packages* que vous utilisez, aux sorties graphiques que vous produisez et aux dossier de votre environnement de travail.

```{r fig08, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Les quatre fenêtres de RStudio",  out.width='85%'}
knitr::include_graphics('images/introduction/r_studio_03.jpeg', dpi = NA)
```

Prenons un bref exemple, tapez la syntaxe suivante dans l'éditeur de code <span class="revision_prop">(fenêtre 1 à la figure \@ref(fig:fig08)) : 

```{r ma_somme}
ma_somme <- 4+4
```

Sélectionnez ensuite cette syntaxe, quand vous utilisez le raccourci *Ctrl+Enter* ou cliquez sur le bouton *Run* (avec la flèche verte), cette syntaxe est envoyée à la console qui l'exécute immédiatement. Notez que rien ne se passe tant que le code n'est pas envoyé à la console. Il s'agit donc de deux étapes distinctes : écrire son code, puis l'envoyer à la console. Vous constaterez également qu'un objet *ma_somme* est apparu dans votre environnement et que sa valeur est bien 8. Votre console se "souvient" de cette valeur, elle est actuellement stockée dans votre mémoire vive sous le nom de *ma_somme* (figure \@ref(fig:fig09)).

```{r fig09, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Les quatre fenêtres de RStudio",  out.width='90%'}
knitr::include_graphics('images/introduction/r_studio_04.jpeg', dpi = NA)
```

Pour terminer sur cette section, nous vous invitons à enregistrer votre première syntaxe ![](images/logos/Rlogo.png) (*File / Save As*) dans un fichier **.R** que vous pouvez appeler par exemple "mon_premier_script.R". Fermez ensuite RStudio, redémarrez le et ouvrez (*File / Open File*) votre fichier "mon_premier_script.R". Vous pouvez constater que votre code est toujours présent, mais que votre environnement est vide tant que vous n'exécutez pas votre syntaxe. En effet, lorsque vous fermez RStudio, l'environnement est vidé pour libérer de la mémoire vive. Ceci peut poser problème lorsque certains codes sont très longs à exécuter, nous verrons donc plus tard comment enregistrer l'environnement en cours pour le recharger par la suite.

Vous êtes prêts à travailler dans ![](images/logos/Rlogo.png) ! Rendez-vous dans la prochaine section pour rentrer dans le vif du sujet.

## Hello World ! {#sect13}

Une introduction à un langage de programmation se doit de commencer par le rite de passage **Hello World**. Il s'agit d'une forme de tradition consistant à montrer aux nouveaux utilisateurs comment afficher le message "Hello World" à l'écran avec le langage en question.

En C, cela donne : 
```
#include <stdio.h>

main()
{
    printf("hello, world\n");
}
```
En COBOL : 
```
IDENTIFICATION DIVISION.
PROGRAM-ID. HELLO-WORLD.

ENVIRONMENT DIVISION.

DATA DIVISION.

PROCEDURE DIVISION.
    DISPLAY "Hello, world!".
    STOP RUN.
```

et plus simplement en ![](images/logos/Rlogo.png) :
```{r}
print("Hello World")
```

Bravo ! Vous venez officiellement de faire votre premier pas dans ![](images/logos/Rlogo.png) !

## Naviguer entre Vecteurs, listes et dataframes {#sect14}

Dans cette section, nous allons aborder la base du langage ![](images/logos/Rlogo.png). Nous resterons largement en surface pour nous concentrer sur les principaux objets que vous aurez besoin de manipuler pour charger, structurer et analyser des données. Une autre section détaillera plus en profondeur le fonctionnement du langage, mais ces éléments ne sont pas nécessaires pour débuter dans ![](images/logos/Rlogo.png). Commençons donc par la base : déclarer des variables.

### Déclarer des variables et les principaux types de variables

Dans ![](images/logos/Rlogo.png), il existe trois principaux types de données de base : 

* Les données numériques, qui peuvent être des nombres entiers (appelés *integers*), ou des nombres décimaux (appelés *floats*), ex `15` et `15.3`: .
* Les données textuelles, qui sont des chaînes de caratères (appelées *strings*) et déclarées entre guillemets `"abcdefg"`
* Les données booléennes (*booleans*) qui représentent les concepts de vrai (`TRUE`) ou de faux (`FALSE`).
* Les données numériques, qui peuvent être des nombres entiers (appelés *integers*), ou des nombres décimaux (appelés *floats*) comme `15` et `15.3`: .
* Les données textuelles, qui sont des chaîne de caratères (appelées *strings*) et déclaré entre guillemets `"abcdefg"`
* Les données booléennes (*booleans*) qui représentent les concepts de vrai : `TRUE` ou de faux `FALSE`.

Pour pouvoir manipuler ces données, il faut préalablement les déclarer. Ceci signifie réserver un espace dans la mémoire vive de votre ordinateur, lui donner un nom et lui associer une valeur; on appelle cette opération déclarer une variable. Une fois cette opération effectuée, la donnée en question est accessible pour effectuer des traitements. Déclarons ensemble quelques variables : 

```{r}
age <- 35
taille <- 175.5
adresse <- '4225 rue de la gauchetiere'
proprietaire <- TRUE
```

Notez ici que le nom des variables ne peut être composé que de lettres, de chiffres, de points (.) et de tiret bas (_) et doit commencer par une lettre. ![](images/logos/Rlogo.png) est sensible à la case, en d'autre termes, les variables `age`, `Age`, `AGe`, et `agE` indiquent toutes un objet différent. Attention donc aux fautes de frappes.

Si vous déclarez une variable en utilisant le nom d'une variable existante, la première est écrasée par la seconde : 

```{r}
age <- 35

print(age)

age <- 45

print(age)
```

Attention donc aux noms de variables que vous utilisez et réutilisez.

### Du vecteur au DataFrame

Nous venons de déclarer (en utilisant le symbole `<-`) quatre variables, nommées respectivement age, taille, adresse et proprietaire, ayant pour types respectifs integer, float, string et boolean. Ces variables pourraient correspondre aux réponses d'un individu à un questionnaire. Jusque là, rien de très impressionnant : les variables déclarées ne décrivent qu'un seul individu. Lors d'une analyse statistique, nous allons travailler avec des volumes de données bien plus conséquents. Pour stocker plusieurs valeurs, nous allons travailler avec ce que l'on appelle des *vecteurs*. Pour déclarer un vecteur, on utilise la fonction *c()* : 

```{r}
ages <- c(35,45,72,56,62)
tailles <- c(175.5,180.3,168.2,172.8,167.6)
adresses <- c('4225 rue de la gauchetiere','4223 rue de la gauchetiere','4221 rue de la gauchetiere','4219 rue de la gauchetiere','4217 rue de la gauchetiere')
proprietaires <- c(TRUE,TRUE,FALSE,TRUE,TRUE)
```

Nous venons ainsi de déclarer 4 nouvelles variables étant chacune un vecteur de longueur 5 (comprenant chacun 5 valeurs). Ces vecteurs représentent les réponses de plusieurs répondants à un questionnaire par exemple.

::: {.bloc_attention .bloc_attention_png data-latex="{blocs/attention}"}
Il existe dans ![](images/logos/Rlogo.png) une subtilité à l'origine de nombreux malentendu : la distinctions entre un vecteur de type texte et un vecteur de type facteur. Dans l'exemple précédent, le vecteur *adresses* est un vecteur de type texte. Chaque nouvelle valeur ajoutée dans le vecteur peut être n'importe quelle nouvelle adresse. Déclarons un nouveau vecteur qui contiendrait cette fois-ci la couleur des yeux de personnes ayant répondu au questionnaire.

```{r}
couleurs_yeux <- c('marron','marron','bleu','bleu','marron','vert')
```

Contrairement aux adresses, il y a un nombre limité de couleur que nous pouvons mettre dans ce vecteur. Il serait intéressant de fixer les valeurs possible du vecteur pour s'assurer que de nouvelles ne soient pas ajoutées par erreur. Pour cela, nous pouvons convertir ce vecteur texte en vecteur de type facteur avec la fonction `as.factor`.

```{r}
couleurs_yeux_facteur <- as.factor(couleurs_yeux)
```

Notez que à présent, nous pouvons ajouter une nouvelle couleur dans le 1er vecteur, mais pas dans le second.

```{r}
couleurs_yeux[7] <- "rouge"
couleurs_yeux_facteur[7] <- "rouge"
```
Le message d'erreur nous informe que nous avons tenté d'introduire une valeur invalide dans le facteur.

Les facteurs peuvent sembler restrictifs et très régulièrement, on préfère travailler avec de simple vecteurs de type texte plutôt que des facteurs. Cependant, de nombreuse fonctions d'analyse nécessitent d'utiliser des facteurs car ils assurent une certaine cohérence dans les données. Il est donc essentiel de savoir passer du texte au facteur avec la fonction `as.factor`. À l'inverse, il est parfois nécessaire de revenir par une variable de type texte avec la fonction `as.character`.

Notez que des vecteurs numérique peuvent aussi être converti en facteur : 

```{r}
tailles_facteur <- as.factor(tailles)
```

Cependant, si vous souhaitez reconvertir ce facteur en format numérique, il faudra passer dans un 1er temps par le format texte : 

```{r}
as.numeric(tailles_facteur)
```

Comme vous pouvez le voir, convertir un facteur en valeur numérique renvoie des nombres entiers. Ceci est du au fait que les valeurs dans un facteur sont recodées sous forme de nombres entiers, chaque nombre correspondant à une des valeurs originales (appelées niveaux). Si on convertit un facteur en valeurs numériques, on obtient donc ces nombres entiers.

```{r}
as.numeric(as.character(tailles_facteur))
```
Moralité de l'histoire, ne confondez pas les données de type texte et de type facteur. Dans le doute, vous pouvez demander à ![](images/logos/Rlogo.png) quel est le type d'un vecteur avec la fonction `class`.

```{r}
class(tailles)
class(tailles_facteur)
class(couleurs_yeux)
class(couleurs_yeux_facteur)
```
:::

Notez tout de suite qu'un vecteur ne peut contenir qu'un seul type de données. Vous ne pouvez pas créer de vecteurs combinant à la fois du texte et des valeurs numériques. Le vecteur est la brique élémentaire de ![](images/logos/Rlogo.png), quasiment toutes les fonctions utilisent des vecteurs. Par exemple, on pourrait calculer la moyenne du vecteur *ages* en utilisant la fonction *mean* présente de base dans ![](images/logos/Rlogo.png).

```{r}
mean(ages)
```

Quand nous disons que le vecteur est la brique élémentaire de ![](images/logos/Rlogo.png), ce n'est pas juste une façon de parler. Techniquement les variables *age*, *taille*, adresse et *proprietaire* définies plus haut sont aussi des vecteurs, mais de longueur 1 !

Il est assez rare de travailler ainsi avec des vecteurs séparés, on préfère généralement avoir ces données stockées dans une structure appelée un *DataFrame* (tableau de données en français). Dans cette structure, chaque ligne du tableau représente un individu et chaque colonne représente une information pour ces individus. Créons ensemble un DataFrame à partir de nos quatres vecteurs.

```{r}
df <- data.frame(
  "age" = ages,
  "taille" = tailles,
  "adresse" = adresses,
  "proprietaire" = proprietaires
)
```

```{r tabfirsttable, echo=FALSE, message=FALSE, warning=FALSE}
knitr::kable(
  df, booktabs = TRUE,
  caption = 'Un premier DataFrame'
)
```

Dans Rstudio, vous pouvez visualiser votre tableau de données avec la fonction `View(df)`. Comme vous pouvez le constater, chaque vecteur est devenu une colonne de votre tableau de données *df*.

La figure \@ref(fig:fig010) résume ce passage d'une simple donnée à un DataFrame en passant par un vecteur.

```{r fig010, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="De la donnée au DataFrame",  out.width='60%'}
knitr::include_graphics('images/introduction/vecteur_to_dataframe.png', dpi = NA)
```

Plusieurs fonctions de base de ![](images/logos/Rlogo.png) peuvent nous donner des informations importantes sur nos Dataframes : 

* *names*, nous donne le noms des colonnes de notre DataFrame,
* *nrow*, le nombre de lignes,
* *ncol*, le nombre de colonnes

```{r}
names(df)
nrow(df)
ncol(df)
```

Vous pouvez accéder à chaque colonne de *df* en utilisant le symbole $ ou [["nom_de_la_colonne"]]. Recalculons ainsi la moyenne des âges :

```{r}
mean(df$age)
mean(df[["age"]])
```

### Charger un DataFrame depuis un fichier et installer un package

Rassurez-vous, il sera rarement nécessaire de créer vos DataFrame à la main comme nous venons de le faire dans l'exemple précédent. Le plus souvent, vous disposerez de fichiers contenant vos données et certaines fonctions vous permettrons de les importer dans ![](images/logos/Rlogo.png) directement sous forme d'un DataFrame. Les formats les plus répandus sont : 

* .csv, il s'agit d'un fichier texte dont chaque ligne représente une ligne du tableau de données dont les colonnes sont séparées par un délimiteur (généralement une virgule ou un point-virgule).
* .dbf, ou fichier dBase, souvent associés à des fichiers d'information géographique ShapeFile,
* .xls et .xlsx, des fichiers générés par Excel
* .json, il s'agit d'un ficher texte utilisant une norme d'écriture propre au langage JavaScript.

Plus rarement, il se peut que vous ayez à charger des fichiers provenant de logiciels concurrents à ![](images/logos/Rlogo.png) : 

* .sas7bdat, provenant du logiciel SAS,
* .sav, provenant du logiciel SPSS,
* .dta, provenant du logiciel STATA.

Pour lire la plupart de ces fichiers, nous allons utiliser le package **foreign**, qui a été développé à cette fin. Pour installer un package, vous devez être connecté à internet, en effet, ![](images/logos/Rlogo.png) va accéder au répertoire de packages *CRAN* pour télécharger le package et l'installer sur votre machine. Cette opération est réalisée avec la fonction `install.packages`

```{r message=FALSE, warning=FALSE, eval=FALSE}
install.packages("foreign")
```

Notez qu'une fois que le package est installé, vous n'aurez plus besoin de le refaire. Le package est disponible localement sur votre ordinateur, à moins de le désinstaller explicitement avec la fonction `remove.packages`.

Pour charger le package dans votre session actuelle de ![](images/logos/Rlogo.png) et accéder aux fonctions qu'il propose, il suffit d'utiliser la fonction `library`. Notez que conventionnellement, l'appel des packages se fait au tout début du script que vous rédigez. Rien ne vous empêche de le faire au fur et à mesure de votre code mais vous perdez alors en lisibilité. 

```{r message=FALSE, warning=FALSE}
library(foreign)
```

Si vous obtenez un message d'erreur du type : 

<span class="error_message">Error in library(mon_package) : aucun package nommé ‘mon_package’ n'est trouvé</span>

C'est que le package que vous tentez de charger n'est pas encore installé sur votre ordinateur. Dans ce cas, réessayer de l'installer avec la fonction `install.packages`. Si le problème persiste, vérifiez que vous n'avez pas fait de faute de frappe dans le nom du package. Vous pouvez également redémarrer RStudio et réessayer d'installer le package.

Nous allons chagrer quatre fois le même jeu de données qui a été enregistré au format csv, dbf, dta et xlsx. Nous allons également enregistrer le temps nécessaire pour lire chacun de ces fichiers avec la fonction `Sys.time`.

#### Lire un fichier csv

Pour le format csv, il n'y a pas besoin d'utiliser un package externe, ![](images/logos/Rlogo.png) dispose d'une fonction de base pour lire ce format.

```{r message=FALSE, warning=FALSE}
t1 <- Sys.time()
df1 <- read.csv("data/priseenmain/SR_MTL_2016.csv", 
         header = TRUE, sep = ",", dec = ".",
         stringsAsFactors = FALSE)
t2 <- Sys.time()
d1 <- difftime(t2,t1,units="secs")

cat('le dataframe df1 a ',nrow(df1),' observations\n')
cat('les colonnes de df1 sont : ',names(df1),"\n")
```

rien de bien compliqué, notez tout de même que : 

* Lorsque vous chargez un fichier csv, vous devez connaître le **séparateur**, il s'agit du caractère utilisé pour délimiter les colonnes de votre csv. Dans notre cas il s'agit d'une simple virgule : ",", mais ça pourrait tout aussi bien être un point virgule ";" une tabulation "    " etc.
* Vous devez également connaître le symbole utilisé pour le décimales. Neuf fois sur dix, ce sera le point ".", mais il se peut que certains logiciel en configuration française vous exportes des fichers csv avec des virgules "," comme symbole de décimale.
* Le paramètre *header* indique si la première ligne (l'entête) du fichier comprend les noms des colonnes du jeu de données. Il arrive que certains fichiers csv soient fournis sans entête, avec le nom et la description des colonnes dans un fichier à part.
* Le paramètre *stringsAsFactors* permet d'indiquer à ![](images/logos/Rlogo.png) que les colonnes comportant du texte doivent être chargées comme des vecteurs de type texte et nom de type facteur. Nous reviendrons sur cette distinction dans la section XXX.

#### Lire un fichier dbf

Pour lire un fichier dbf, nous allons devoir utiliser le package foreign que nous avons installé précédemment : 

```{r message=FALSE, warning=FALSE}
library(foreign)

t1 <- Sys.time()

df2 <- read.dbf("data/priseenmain/SR_MTL_2016.dbf")

t2 <- Sys.time()
d2 <- difftime(t2,t1,units="secs")

cat('le dataframe df2 a ',nrow(df2),' observations\n')
cat('les colonnes de df2 sont : ',names(df2),"\n")
```
Comme vous pouvez le constater, nous obtenons exactement les mêmes résultats qu'avec le fichier csv

#### Lire un fichier dta

Si vous travaillez avec des collègues utilisant le logiciel STATA, il se peut que ces derniers vous partagent des fichiers dta. En utilisant à nouveau le package **foreign**, vous serez en mesure de les charger directement dans ![](images/logos/Rlogo.png).

```{r message=FALSE, warning=FALSE}
t1 <- Sys.time()

df3 <- read.dta("data/priseenmain/SR_MTL_2016.dta")

t2 <- Sys.time()
d3 <- difftime(t2,t1,units="secs")

cat('le dataframe df3 a ',nrow(df3),' observations\n')
cat('les colonnes de df3 sont : ',names(df3),"\n")
```

#### Lire un fichier sas7bdat

De même, il existe de nombreux milieux où le logiciel SAS est très utilisé. Si l'on vous partage un fichier sas7bdat, vous pourrez l'ouvrir avec le package **sas7bdat**

```{r message=FALSE, warning=FALSE}
library(sas7bdat)
t1 <- Sys.time()

df4 <- read.sas7bdat("data/priseenmain/SR_MTL_2016.sas7bdat")

t2 <- Sys.time()
d4 <- difftime(t2,t1,units="secs")

cat('le dataframe df4 a ',nrow(df4),' observations\n')
cat('les colonnes de df4 sont : ',names(df4),"\n")
```

#### Lire un fichier xlsx

Lire un fichier excel dans ![](images/logos/Rlogo.png) n'est pas une chose facile. Généralement, nous recommandons d'exporter les fichiers en question au format csv dans un premier temps. Il est cependant possible de directement lire un fichier xlsx avec le package **xlsx**. Ce dernier requiert que le logiciel JAVA soit installé sur votre ordinateur (Windows, Mac ou Linux). Si vous utilisez la version 64 bit de ![](images/logos/Rlogo.png), vous devrez télécharger et installer la version 6
 bit de JAVA. Une fois que ce logiciel tiers est installé, il ne vous reste plus qu'à installer le package **xlsx** (`install.packages("xlsx")`) et à le charger.

```{r message=FALSE, warning=FALSE}
library(xlsx)

t1 <- Sys.time()

df5 <- read.xlsx("data/priseenmain/SR_MTL_2016.xlsx",sheetIndex = 1,
                 as.data.frame = TRUE)

t2 <- Sys.time()
d5 <- difftime(t2,t1,units="secs")


cat('le dataframe df5 a ',nrow(df5),' observations\n')
cat('les colonnes de df5 sont : ',names(df5),"\n")
```

Il est possible de nettement accelérer la vitesse de lecture d'un fichier xlsx en utilisant la fonction `read.xlsx2`. Il faut cependant indiquer à cette derniére le type de données que l'on doit trouver dans chaque colonne. Dans le cas présent, nous savons que les 5 premières colonnes contiennent des données au format texte (character), alors que les 43 autres sont des données numériques (numeric). Pour ces dernières, nous allons utiliser la fonction *rep* afin de ne pas avoir à écrire 43 fois le mot numeric.

```{r message=FALSE, warning=FALSE}
library(xlsx)

t1 <- Sys.time()

df6 <- read.xlsx2("data/priseenmain/SR_MTL_2016.xlsx",sheetIndex = 1, 
                  as.data.frame = TRUE,
                  colClasses = c("character","character","character","character","character",rep("numeric",43)))

t2 <- Sys.time()
d6 <- difftime(t2,t1,units="secs")

cat('le dataframe df6 a ',nrow(df6),' observations\n')
cat('les colonnes de df6 sont : ',names(df6),"\n")
```

Si l'on compare les temps d'exécution du tableau \@ref(tab:tableduration), on constate que la lecture des fichiers xlsx peut être extrèmement longue si l'on ne spécifie pas le type des colonnes. Ceci peut devenir un problème majeur pour des fichier volumineux. Notez également que la lecture des fichiers csv devient de plus en plus laborieuse à mesure que la taille du fichier csv augment. Si vous devez un jour charger des fichiers csv de plusieurs giga octets, nous vous recommandons d'utiliser la fonction `fread` du package **data.table** qui est beaucoup plus rapide.

```{r tableduration, message=FALSE, warning=FALSE}

durations <- data.frame(
  "duree" = c(d1,d2,d3,d4,d5,d6),
  "fonction" = c("read.csv","read.dbf","read.dta",
                 'read.sas7bdat',"read.xlsx","read.xlsx2")
)

knitr::kable(
  durations, booktabs = TRUE,digits = 2,
  col.names = c("Durée (s)","fonction"),
  caption = 'Temps nécessaire pour lire les données en fonction du type de fichier'
)

```
### Manipuler un DataFrame

Maintenant que nous savons comment définir et charger un DataFrame, nous allons apprendre à les manipuler.

Avant d'aller plus loin, il est important d'introduire brièvement un débat actuel dans la communauté ![](images/logos/Rlogo.png). Depuis entre 2010 et 2020 s'est peu à peu imposé sur le devant de la scène le package **tidyverse**. Plus exactement, **tidyverse** est un ensemble de packages, pensés pour faciliter la structuration et la manipulation des données dans ![](images/logos/Rlogo.png). Développé et maintenu par Hadley Wickham, ce package introduit une philosophie et une grammaire spécifiques, qui diffèrent du langage ![](images/logos/Rlogo.png) traditionnel. Une partie de la communauté a pour ainsi dire complètement embracé le **tidyverse** et de nombreux packages en dehors du **tidyverse** ont adopté sa grammaire et sa philosophie. À l'inverse, une autre partie de la communauté est [opposée](https://blog.ephorie.de/why-i-dont-use-the-tidyverse) à cette évolution. On peut résumer les arguments des deux partis avec le tableau suivant : 

Avantages du **tidyverse** | Problèmes posés par le **tidyverse**
-------------------------- | ------------------------------------ 
Simplicité d'écriture et d'apprentissage | Nouvelle syntaxe à apprendre
Ajout de l'opérateur %>% permettant d'enchaîner les traitements | Perte de lisibilité avec l'opérateur ->
La meilleure librairie pour réaliser des graphiques : **ggplot2** | Certaines fonctions de base sont remplacées par **tidyverse** lors de son chargement, pouvant créer des bugs.
Crée un écosystème cohérent | Rajoute une dépendance dans le code
Package en développement et de plus en plus utilisé  | Philosophie d'évolution aggressive, aucune assurance de rétro-compatibilité

Le dernier point est probablement le plus problématique. Dans sa volonté d'évoluer au mieux et sans restriction, le package **tidyverse** n'offre aucune garantie de rétro-comptatibilité. En d'autre termes, des changements importants peuvent être introduit d'une version à l'autre rendant potentiellement obsolète votre propre code.

Nous n'avons pas d'opinion tranchée sur le sujet. **tidyverse** est un outil très intéressant dans de nombreux cas. Nous évitons simplement de l'utiliser en permanence et préférons charger directement les sous-packages (comme **dplyr** ou **ggplot2**) du **tidyverse** dont nous avons besoin.

Notez que le package **data.table** offre une alternative au **tidyverse** dans la manipulation de données. Au prix d'un syntaxe généralement un peu plus complexe **data.table** offre une vitesse de calcul bien supérieure au **tidyverse** et assure une bonne rétro-compatibilité.


#### Gérer les colonnes d'un DataFrame

Repartons du DataFrame que nous avions chargé précédemment grâce à un fichier csv.

```{r message=FALSE, warning=FALSE}
df <- read.csv("data/priseenmain/SR_MTL_2016.csv", 
         header = TRUE, sep = ",", dec = ".",
         stringsAsFactors = FALSE)
```

##### Sélectionner une colonne
Pour rappel, il est possible d'accéder aux colonnes dans ce DataFrame en utilisant l'opérateur `$ma_colonne` ou les doubles crochets `[["ma_colonne"]]`

```{r message=FALSE, warning=FALSE}
#calcul de la superficie totale de l'Île de Montréal
sum(df$KM2)
sum(df[["KM2"]])
```

##### Sélectionner plusieurs colonnes
Il est possible de sélectionner plusieurs colonnes d'un DataFrame. On peut ainsi filtrer des colonnes inutiles. Pour cela, on peut utiliser un vecteur contenant la position de la colonne (1 pour la première colonne, 2 pour la seconde et ainsi de suite), ou un vecteur contenant le nom des colonnes.

```{r message=FALSE, warning=FALSE}
#garder les 5 premières colonnes
df2 <- df[1:5]

#garder les colonnes 1,5,10 et 15
df3 <- df[c(1,5,10,15)]

#garder les colonnes 1 à 5, 7 à 12, 17 et 22
df4 <- df[c(1:5,7:12,17,22)]

#garder les colonnes avec leurs noms
df5 <- df[c("SRIDU","KM2","Pop2016","MaisonIndi","LoyerMed")]

```

##### Supprimer des colonnes
Il peut être plus intéressant de directement supprimer des colonnes plutôt que de recréer un nouveau DataFrame. Pour cela, on va attribuer la valeur `NULL` à ces colonnes

```{r message=FALSE, warning=FALSE}
#supprimer le colonnes 2,3 et 5
df3[c(2,3,5)] <- list(NULL)

#supprimer une colonne avec son nom
df4$OID <- NULL

#supprimer des colonnes par leur nom
df5[c("SRIDU","LoyerMed")] <- list(NULL)
```
Notez que si vous supprimez une colonne, vous ne pouvez pas revenir en arrière. Il faudra recharger votre jeu de données ou relancer les calculs qui avaient produit cette colonne.

##### Renommer des colonnes
Il est possible de changer le nom d'un colonne. Cette opération est importante pour faciliter la lecture du DataFrame ou s'assurer que l'on n'aura pas de problème lorsque l'on exportera le DataFrame dans un fichier.

```{r message=FALSE, warning=FALSE}
#voici les anciens noms
names(df5)

#renommer toutes les colonnes
names(df5) <- c('superficie_km2','population_2016', 'maison_individuelle_prt')
names(df5)

#renommer avec dplyr
library(dplyr)
df4 <- rename(df4, "population_2016" = "Pop2016",
              "prs_moins_14ans_prt" = "A014",
              "prs_15_64_ans_prt" = "A1564",
              "prs_65plus_ans_prt" = "A65plus"
              )
```


#### Opérateurs mathématique

Il est possible d'utiliser les colonnes de type numérique pour calculer de nouvelles colonnes. Les opérateurs disponibles sont : 

* `+` pour les additions
* `-` pour les soustractions
* `*` pour les multiplications
* `/` pour les divisions
* `^` ou `**` pour les puissances
* `%%` pour le modulus (reste d'une division)

Prenons un exemple concret et calculons la densité de population par secteur de recensement dans notre précédent DataFrame et affichons un résumé de cette nouvelle variable.

```{r message=FALSE, warning=FALSE}

# calcul de la densité
df$pop_density_2016 <- df$Pop2016 / df$KM2

summary(df$pop_density_2016)
```

Nous pouvons aussi calculer le ratio entre le nombre de maisons et le nombre d'appartements.

```{r message=FALSE, warning=FALSE}

# calcul de la densité
df$total_maison <- (df$MaisonIndi + df$MaisJumule + df$MaisRangee + df$AutreMais)
df$total_apt <- (df$AppDuplex + df$App5Moins + df$App5Plus)
df$ratio_maison_apt <- df$total_maison / df$total_apt

summary(df$pop_density_2016)
```

Ce qu'il faut retenir ici, c'est que ![](images/logos/Rlogo.png) va appliquer le calcul à chaque ligne de votre jeu de données et stocker le résultat dans une nouvelles colonne. On appelle cela du calcul vectorisé : toute la colonne est calculée en une seule fois. ![](images/logos/Rlogo.png) est optimisé pour faire du calcul vectoriel.

#### fonctions mathématique

![](images/logos/Rlogo.png) propose un ensemble de fonctions de base pour effectuer du calcul. Voici une liste des principales fonctions (non-exhaustive) : 

* `abs` : calcule les valeurs absolue des valeurs d'un vecteur
* `sqrt` : calcule les racines carrés des valeurs d'un vecteur
* `log` : calcule les logarithmes des valeurs d'un vecteur
* `exp` : calcule les exponentiels des valeurs d'un vecteur
* `factorial` : calcule la factorielle des valeurs d'un vecteur
* `round` : arrondit les valeurs d'un vecteur
* `ceiling`, `floor` : arrondit à l'unité supérieure ou inférieure les valeurs d'un vecteur
* `sin`,`asin`,`cos`,`acos`,`tan`,`atan` : les fonctions de trigonométrie classiques

Ces fonctions sont des fonctions vectorielles. Elles s'appliquent à tous les éléments d'un vecteur. Si vous vecteur en entrée comprends 5 valeurs, le vecteur en sortie comprendra 5 valeurs également.

* `sum` : calcule la somme des valeurs d'un vecteur
* `cumSum` : calcule la somme cumulative des valeurs d'un vecteur
* `prod` : calcule le produit des valeurs d'un vecteur
* `min`, `max` : renvoit les valeurs maxmimales et minimale d'un vecteur
* `mean`, `median` : renvoit la moyenne et la médiane d'un vecteur
* `quantile` : renvoit les percentiles d'un vecteur

#### fonctions pour manipuler du texte

En plus des données numérique, vous aurez à travailler avec des données textuelles. Le **tidyverse** avec le packages **stringr** offre des fonctions très intéressantes pour manipuler du texte. Pour un aperçu de toutes les fonctions offertes par **stringr**, vou spouvez référer à sa [Cheat Sheet](https://github.com/rstudio/cheatsheets/blob/master/strings.pdf). Commençons avec un DataFrame assez simple comprenant des adresses et des noms de personnes.

```{r message=FALSE, warning=FALSE}
library(stringr)

df <- data.frame(
  noms = c("Liliana ford","faram mcclure","shanice Howells","Nella Cardenas"),
  adresses = c('152 rue Levy', '4138 Blvd René-Lévesque', '3606 rue Duké', '2457 route St Marys')
)
```

##### Majuscules et minuscules

Pour harmoniser ce dataframe, nous allons dans un 1er temps harmoniser les majuscules des noms des individus avec la fonction `str_to_title`.

```{r message=FALSE, warning=FALSE}
df$noms_corr <- str_to_title(df$noms)
df$noms_corr
```

On pourrait également tout mettre en minuscule ou tout en majuscule.
```{r message=FALSE, warning=FALSE}
df$noms_min <- tolower(df$noms)
df$noms_maj <- toupper(df$noms)
df$noms_min
df$noms_maj
```

##### Remplacer du texte

Dans les adresses, nous avons des caractères accentués. Ce type de caractère peut poser des problèmes d'encodage et nous pourrions décider des les remplacer par des caractères simples avec la fonction `str_replace_all`.

```{r message=FALSE, warning=FALSE}
df$adresses_1 <- str_replace_all(df$adresses,'é','e')
```

Nous pouvons utiliser la même fonction pour remplacer les St par Saint et les Blvd par Boulevard.

```{r message=FALSE, warning=FALSE}
df$adresses_2 <- str_replace_all(df$adresses_1,' St ',' Saint ')
df$adresses_3 <- str_replace_all(df$adresses_2,' Blvd ',' Boulevard ')
df$adresses_3
```
##### Découper du texte

Il est parfois nécessaire de découper du texte pour en extraire des éléments. On doit alors choisir un caractère de découpage. Dans notre cas, on pourrait vouloir extraire les numéros civiques des addresse, en utilisant le premier espace comme caractère de découpage. Ce qui est faisables avec la fonction `str_split_fixed`.

```{r message=FALSE, warning=FALSE}
df$num_civique <- str_split_fixed(df$adresses_3, ' ',n=2)[,1]
```

Pour être exact, sachez que dans notre example, la fonction `str_split_fixed` renvoie deux colonnes de texte : une avec le texte avec le 1er espace (donc le numéros civique) et une avec le reste du texte. En ajoutant `[,1]` à la fin, nous indiquons que nous souhaitons seulement garder la 1ère des deux colonnes. La deuxième est donc perdue, mais nous souhaitions de toute façon pas la garder.

##### Coller du texte

À l'inverse du découpage, il est parfois nécessaire de coller ensemble des éléments de texte, ce que nous pouvons faire avec la fonction `paste`.

```{r message=FALSE, warning=FALSE}
df$texte_complet <- paste(df$noms_corr, df$adresses_3, sep = " : ")
df$texte_complet
```

Le paramètre *sep* permet de choisir les caractères à intercaler entre les éléments  copier. Notez qu'il est possible de coller plus que deux éléments ensembles : 

```{r message=FALSE, warning=FALSE}
df$ville <- c('Montreal','Montreal','Montreal','Montreal')
paste(df$noms_corr, df$adresses_3, df$ville, sep = "  ")
```
#### Sous sélection d'un DataFrame


toupper ; tolower ; gsub ; separate ; paste  


	0.4 importer et manipuler des données
		créer un dataframe
		charger un dataframe
		extraire une colonne ⇒ vecteur
		opérateur mathématique
		subsetting et opérateur logique
		fusion, aggregation, jointure
		créer des nouvelles colonnes (exemple de densité, % etc.)
		subsetting
		
		r language essential (voir chap1 de introductory statistics with R)
	0.5 la syntaxe des graphiques (philosophie de ggplot2)
