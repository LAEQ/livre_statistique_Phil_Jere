# Prise en main de R

Dans ce chapitre, nous reviendrons brièvement sur l’histoire de ![](images/logos/Rlogo.png) et la philosophie qui entoure le logiciel. Nous donnerons quelques conseils pour son installation et la mise en place d’un environnement de développement. Nous présenterons les principaux objets qui sous-tendent le travail effectué avec ![](images/logos/Rlogo.png) (dataframe, vecteur, matrice, etc.) et comment les manipuler avec des exemples appliqués. Enfin, nous terminerons cette section avec un tour d’horizon des capacités graphiques de ![](images/logos/Rlogo.png).

## Histoire et philosophie de ![](images/logos/Rlogo.png){#sect11}

![](images/logos/Rlogo.png) est à la fois un langage de programmation et un logiciel libre (sous la licence publique générale GNU) dédié à l'analyse statistique et supporté par une fondation : _R foundation for Statistical computing_. Il est principalement écrit en C et Fortran.

![](images/logos/Rlogo.png) est l'héritier de S, un autre langage de programmation dédié à l'analyse statistique publié pour la première fois en 1976 et créé par John Chambers pour l'entreprise Nokia (Bell Laboratories). S a donné naissance à S-PLUS (logiciel propriétaire) et à son frère ![](images/logos/Rlogo.png) (logiciel libre). L'idée centrale derrière le développement de S était de faciliter le passage rapide et fidèle de l'idée à l'implémentation [@chambers1998programming]. Cet état d'esprit est encore un des fondements de la philosophie de ![](images/logos/Rlogo.png).

![](images/logos/Rlogo.png) a été créé par Ross Ihaka et Robert Gentleman à l'Université d'Auckland en Nouvelle Zélande. Si vous avez un jour l'occasion de passer dans le coin, une plaque est affichée dans le département de statistique de l'université, ça mérite le détour (figure \@ref(fig:fig01)). Une première version a été publiée en 1996, mais la première version stable ne date que de 2000, il s'agit donc d'un logiciel relativement récent si on le compare à ses concurrents SAS (1976), SPSS (1968) et Stata (1984).

```{r fig01, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Lieu de pélerinage de R",  out.width='60%'}
knitr::include_graphics('images/introduction/plaque.jpg', dpi = NA)
```

![](images/logos/Rlogo.png) a cependant réussi à s'imposer tant dans la milieu de la recherche que dans le secteur privé. Pour s'en convaincre, il suffit de lire l'excellent article concernant [la popularité des logiciels d'analyse de données](http://r4stats.com/articles/popularity/){target="_blank"} tirée du site [r4stats.com](http://r4stats.com){target="_blank"} (figure \@ref(fig:fig02)). 

```{r fig02, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Nombre d'articles trouvés sur Google Scholar (Source : Robert A. Muenchen)",  out.width='50%'}
knitr::include_graphics('images/introduction/r_citations.jpg', dpi = NA)
```

Les nombreux atouts de ![](images/logos/Rlogo.png) justifient largement sa popularité sans cesse croissante : 

* ![](images/logos/Rlogo.png) est un logiciel à code source ouvert (*open source*) et ainsi accessible à tous gratuitement.
* Le développement du langage ![](images/logos/Rlogo.png) est centralisé, mais la communauté peut créer et partager facilement des *packages*. Les nouvelles méthodes sont ainsi rapidement implémentées comparativement aux logiciels propriétaires.
* ![](images/logos/Rlogo.png) est un logiciel multi-plateforme, fonctionnant sur Linux, Unix, Windows et Mac.
* Comparativement à ses concurrents, ![](images/logos/Rlogo.png) dispose d'excellentes solutions pour manipuler des données et réaliser des graphiques.
* ![](images/logos/Rlogo.png) dispose de nombreuses interfaces lui permettant de communiquer, notamment avec des systèmes de bases de données SQL et non SQL (MySQL, PostgresSQL, MongoDB, etc.), à des systèmes de *big data* (Spark, Hadoop), à des systèmes d'information géographique (QGIS, ArcGIS) et même à des services en ligne comme Microsoft Azure ou Amazon AWS.
* ![](images/logos/Rlogo.png) est un langage de programmation à part entière, ce qui lui donne plus de flexibilité que ses concurrents dans le domaine privé (SPSS, SAS, STATA). Avec ![](images/logos/Rlogo.png), vous pouvez accomplir des tâches aussi variées que : monter un site web, créer un robot collectant des données en ligne, effecter des analyses qualitatives, combiner des fichiers PDF, composer des diapositives pour une présentation ou même éditer un livre (comme celui-ci), mais aussi réaliser des analyses statistiques.

Un des principaux attrait de ![](images/logos/Rlogo.png) est la quantité astronomique de *packages* actuellement disponibles. Un *package* est un ensemble de nouvelles fonctionnalités développées par un ou plusieurs utilisateurs de ![](images/logos/Rlogo.png) et mises à disposition de l'ensemble de la communauté. Par exemple, le *package* **ggplot2** est dédié à la réalisation de graphiques; les *packages* **data.table** et **plyr** permettent de manipuler des tableaux de données; le *package* **car** apporte de nombreux outils pour faciliter l'analyse de modèles de régressions, etc. Ce partage des *packages* rend accessible à tous des méthodes d'analyses complexes et récentes et favorise grandement la reproductibilité de la recherche. Cependant, ce fonctionnement implique quelques désavantages : 

* il existe généralement plusieurs *packages* pour effectuer le même type d'analyse ce qui peut devenir une source de confusion;
* certains *packages* cessent d'être mis à jour au fil des années, ce qui nécessite de leur trouver d'autres alternatives (et ainsi apprendre la syntaxe des nouveaux *packages*);
* il est impératif de s'assurer de la fiabilité des *packages* que vous souhaitez utiliser car n'importe qui peut proposer un *package*.

Il nous semble important de relativiser d'emblée la portée du dernier point. Il est rarement nécessaire de lire et analyser le code source d'un *package* pour s'assurer de sa fiabilité. Nous ne sommes pas des spécialistes de tous les sujets et il peut être extrêmement ardu de comprendre la logique d'un code écrit par quelqu'un d'autre. Nous vous recommandons donc de privilégier l'utilisation de *packages* qui :

* ont fait l'objet d'une publication dans une revue à comité de lecture ou qui ont déjà été cités dans dans des études ayant fait l'objet d'une publication revue par les pairs;
* font partie de projets comme [ROpensci](https://ropensci.github.io/reproducibility-guide/sections/introduction/){target="_blank"} prônant la vérification  par les pairs ou subventionnés par des organisations comme [R Consortium](https://www.r-consortium.org/){target="_blank"}.
* sont disponibles sur l'un des deux principaux répertoires de *packages* R [CRAN](https://cran.r-project.org/){target="_blank"} ou [Bioconductor](https://www.bioconductor.org/){target="_blank"}.

Toujours pour nuancer notre propos, il convient de distinguer *package* de *package*! Certains d'entre eux sont des ensembles très complexes de fonctions permettant de réaliser des analyses poussées alors que d'autres sont des projets plus modestes dont l'objectif principal est de simplifier le travail des utilisateurs. Ces derniers ressemblent à des petites boites à outils et font généralement moins l'objet d'une vérification intensive.

Pour conclure cette section, l'illustration partagée sur Twitter par Darren L Dahly résume avec humour la force du logiciel ![](images/logos/Rlogo.png) et de sa communauté (\@ref(fig:fig03)) : ![](images/logos/Rlogo.png) apparait clairement comme une communauté hétéroclyte, mais diversifiée et adaptable.

```{r fig03, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Métaphore sur les langages et programmes d'analyse statistique",  out.width='60%'}
knitr::include_graphics('images/introduction/softwares_and_cars.jpeg', dpi = NA)
```

Dans ce livre, nous détaillerons les **packages** utilisés dans chaque section avec un encadré spécifique, accompagné de l'icône suivant : 

```{r fig04, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Icône des encadrés dédiés aux packages",  out.width='20%'}
knitr::include_graphics('css/images/package.png', dpi = NA)
```

## Environnement de travail

Dans cette section, nous vous proposons une visite de l'environnement de travail classique  ![](images/logos/Rlogo.png).

### Installer ![](images/logos/Rlogo.png)

La première étape pour travailler avec ![](images/logos/Rlogo.png) est bien sûr de l'installer. Pour ce faire, il suffit de visiter le site web de [CRAN](https://cran.r-project.org/){target="_blank"} et de télécharger la dernière version de ![](images/logos/Rlogo.png) en fonction de votre système d'exploitation : Windows, Linux ou Mac. Une fois installé, si vous démarrez ![](images/logos/Rlogo.png) immédiatement, vous aurez alors accès à une console, plutôt rudimentaire, attendant sagement vos instructions (figure \@ref(fig:fig05)).

```{r fig05, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="La console de base de R",  out.width='85%'}
knitr::include_graphics('images/introduction/r_console.jpeg', dpi = NA)
```

Notez que vous pouvez aussi télécharger des version plus anciennes de ![](images/logos/Rlogo.png) en allant sur ce [lien](https://cran.r-project.org/bin/windows/base/old/){target="_blank"}. Ceci peut être intéressant lorsque vous voulez reproduire des résultats d'une autre étude ou que certains *packages* ne sont plus disponibles dans les nouvelles versions.

### L'environnement RStudio

Rares sont les utilisateurs de ![](images/logos/Rlogo.png) qui préfèrent travailler directement avec la console classique. Nous vous recommandons vivement d'utiliser RStudio, soit un environnement de développement dédié à ![](images/logos/Rlogo.png), offrant une intégration très intéressante d'une console, d'un éditeur de texte, d'une fenêtre de visualisation des données, d'une autre pour les graphiques, d'un accès à la documentation, etc. En d'autres termes, si ![](images/logos/Rlogo.png) est vélo minimaliste, RStudio permet d'y rajouter des freins, des vitesses, un porte-bagage, des gardes boues et une selle confortable. Vous pouvez [télécharger](https://rstudio.com/products/rstudio/download){target="_blank"} et installer RStudio sur Windows, Linux et Mac. La version de base est gratuite, mais l'entreprise qui développe ce logiciel propose aussi des versions commerciales du logiciel qui assurent essentiellement un support technique. Il existe d'autres environnements de développement pour travailler avec ![](images/logos/Rlogo.png) (VisualStudio, Jupyter, Tinn-R, Radiant, RIDE, etc.), mais RStudio offre à ce jour la meilleure option en terme de facilité d'installation, de prise en main et de fonctionnalités proposées (voir l'interface de RStudio à la figure \@ref(fig:fig06)).

```{r fig06, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Environnement de base de RStudio",  out.width='85%'}
knitr::include_graphics('images/introduction/r_studio_01.jpeg', dpi = NA)
```

Avant d'aller plus loin, notez que : 

* La console actuellement ouverte dans RStudio vous informe de la version de ![](images/logos/Rlogo.png) que vous utilisez. Vous pouvez en effet avoir plusieurs versions de ![](images/logos/Rlogo.png) installées sur votre ordinateur et passer de l'une à l'autre avec RStudio. Pour cela, naviguez dans l'onglet *Tools / Global Options* et dans le volet  *General*, vous pouvez sélectionner la version de ![](images/logos/Rlogo.png) que vous souhaitez utiliser.
* L'aspect de RStudio peut être modifié en navigant dans l'onglet *Tools / Global Options* et dans le volet *Appareance*. Nous avons une préférence pour le mode sombre avec le style *pastel on dark*, mais libre à chacun de choisir le style qui lui convient.

```{r fig07, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="RStudio avec le style pastel on dark",  out.width='85%'}
knitr::include_graphics('images/introduction/r_studio_02.jpeg', dpi = NA)
```

Une fois ces détails réglés, vous pouvez ouvrir votre première feuille de code en allant dans l'onglet *File / New File/ R Script*, votre environnement est maintenant découpé en quatre fenêtres (figure \@ref(fig:fig08)) : 

1. L'éditeur de code, vous permettant d'écrire le script que vous voulez exécuter et permettant de garder une trace de votre travail. Ce script peut être enregistré sur votre ordinateur avec l'extension **.R**, mais ce n'est qu'un simple fichier texte.
2. La console vous permettant d'exécuter votre code R et de voir les résultats s'afficher au fur et à mesure.
3. La fenêtre d'environnement vous montrant les objets, fonctions et jeux de données actuellement disponibles dans votre session (chargés dans la mémoire vive).
4. La fenêtre de l'aide, des graphiques et de l'explorateur de fichiers. Vous pouvez accéder ici à la documentation de ![](images/logos/Rlogo.png) et des *packages* que vous utilisez, aux sorties graphiques que vous produisez et aux dossier de votre environnement de travail.

```{r fig08, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Les quatre fenêtres de RStudio",  out.width='85%'}
knitr::include_graphics('images/introduction/r_studio_03.jpeg', dpi = NA)
```

Prenons un bref exemple, tapez la syntaxe suivante dans l'éditeur de code (fenêtre 1 à la figure \@ref(fig:fig08)) : 

```{r ma_somme}
ma_somme <- 4+4
```

Sélectionnez ensuite cette syntaxe (mettre en surbrillance avec votre souris), quand vous utilisez le raccourci *Ctrl+Enter* ou cliquez sur le bouton *Run* (avec la flèche verte), cette syntaxe est envoyée à la console qui l'exécute immédiatement. Notez que rien ne se passe tant que le code n'est pas envoyé à la console. Il s'agit donc de deux étapes distinctes : écrire son code, puis l'envoyer à la console. Vous constaterez également qu'un objet *ma_somme* est apparu dans votre environnement et que sa valeur est bien 8. Votre console se "souvient" de cette valeur, elle est actuellement stockée dans votre mémoire vive sous le nom de *ma_somme* (figure \@ref(fig:fig09)).

```{r fig09, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Les quatre fenêtres de RStudio",  out.width='90%'}
knitr::include_graphics('images/introduction/r_studio_04.jpeg', dpi = NA)
```

Pour terminer sur cette section, nous vous invitons à enregistrer votre première syntaxe ![](images/logos/Rlogo.png) (*File / Save As*) dans un fichier **.R** que vous pouvez appeler par exemple "mon_premier_script.R". Fermez ensuite RStudio, redémarrez le et ouvrez (*File / Open File*) votre fichier "mon_premier_script.R". Vous pouvez constater que votre code est toujours présent, mais que votre environnement est vide tant que vous n'exécutez pas votre syntaxe. En effet, lorsque vous fermez RStudio, l'environnement est vidé pour libérer de la mémoire vive. Ceci peut poser problème lorsque certains codes sont très longs à exécuter, nous verrons donc plus tard comment enregistrer l'environnement en cours pour le recharger par la suite.


### Installer et charger un *package*

Dans la section sur la Philosophie de ![](images/logos/Rlogo.png), nous avons souligné la place centrale jouée par les *packages*. Voyons ensemble comment installer un *package* intitulé **lubridate**, qui nous permettra plus tard de manipuler des données temporelles.

#### Installer un *package* depuis CRAN

Pour installer un *package*, vous devez être connecté à internet, en effet, ![](images/logos/Rlogo.png) va accéder au répertoire de *packages* *CRAN* pour télécharger le *package* et l'installer sur votre machine. Cette opération est réalisée avec la fonction `install.packages`.

```{r message=FALSE, warning=FALSE, eval=FALSE}
install.packages("lubridate")
```

Notez qu'une fois que le *package* est installé, vous n'aurez plus besoin de le refaire. Le *package* est disponible localement sur votre ordinateur, à moins de le désinstaller explicitement avec la fonction `remove.packages`.

#### Installer un *package* depuis GitHub

*CRAN* est le répertoire officiel des *packages* de ![](images/logos/Rlogo.png). Vous pouvez cependant télécharger des *packages* provenant d'autres sources. Très souvent, les *packages* sont disponibles sur le site web [GitHub](https://github.com/){target="_blank"} et l'on peut même y trouver des versions en développement avec des fonctionnalités encore non intégrées dans la version sur *CRAN*. Reprenons le cas de **lubridate**, sur GitHub, il est disponible à la page [suivante](https://github.com/tidyverse/lubridate){target="_blank"}. Pour l'installer nous devons d'abord installer un autre *package* appelé **devtools** (depuis *CRAN*).

```{r message=FALSE, warning=FALSE, eval=FALSE}
install.packages("devtools")
```

Maintenant que nous disposons de **devtools**, nous pouvons utiliser la fonction d'installation `devtools::install_github` pour directement télécharger **lubridate** depuis GitHub.

```{r message=FALSE, warning=FALSE, eval=FALSE}
devtools::install_github("tidyverse/lubridate")
```

#### Charger un *package*

Maintenant que **lubridate** est installé, nous pouvons le charger dans notre session actuelle de ![](images/logos/Rlogo.png) et accéder aux fonctions qu'il propose. Pour cela, suffit d'utiliser la fonction `library`. Notez que conventionnellement, l'appel des *packages* se fait au tout début du script que vous rédigez. Rien ne vous empêche de le faire au fur et à mesure de votre code mais vous perdez alors en lisibilité.  

```{r message=FALSE, warning=FALSE}
library(lubridate)
```

Si vous obtenez un message d'erreur du type : 

<span class="error_message">Error in library(mon_package) : aucun *package* nommé ‘mon_package’ n'est trouvé</span>

C'est que le *package* que vous tentez de charger n'est pas encore installé sur votre ordinateur. Dans ce cas, réessayer de l'installer avec la fonction `install.packages`. Si le problème persiste, vérifiez que vous n'avez pas fait de faute de frappe dans le nom du *package.* Vous pouvez également redémarrer RStudio et réessayer d'installer le *package*.

### Obtenir de l'aide

Lorsque vous installez des *packages* dans ![](images/logos/Rlogo.png), vous téléchargez aussi leur documentation. Tous les *packages* de *CRAN* disposent d'une documentation, mais ceci n'est pas forcément vrai pour *GitHub*. Dans RStudio, vous pouvez accéder à la documentation des *packages* dans l'onglet **Packages** (figure \@ref(fig:fig010)). Vous pouvez utiliser la barre de recherche, pour retrouver rapidement un *package* installé. Si vous cliquez sur le nom du *package*, vous accédez directement à sa documentation dans cette fenêtre.

```{r fig010, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Description des packages",  out.width='45%'}
knitr::include_graphics('images/introduction/rstudio_packages.jpeg', dpi = NA)
```

Vous pouvez également accéder à ces informations en utilisant la syntaxe suivante dans votre console : 

```{r eval = FALSE}
help(package = 'lubridate')
```

Souvent, vous aurez besoin d'accéder à la documentation d'une fonction spécifique d'un *package*. Affichons la documentation de la fonction `now` de **lubridate** : 

```{r eval = FALSE}
help(now, package = 'lubridate')
```

ou plus simplement :
```{r eval = FALSE}
?lubridate::now
```


Vous pouvez aussi utiliser le raccourci suivant : 

```{r eval = FALSE}
?now
```

Si vous connaissez le nom d'une fonction, mais vous ne vous souvenez plus à quel *package* elle appartient, lancez une recherche en utilisant un double point d'interrogation : 

```{r eval = FALSE}
??now
```

Vous allez ainsi découvrir que la fonction `now` n'existe pas que dans **lubridate**, ce qui souligne l'importance de bien connaître les *packages* que l'on installe et que l'on charge dans notre session ! 

Maintenant que nous avons fait le tour de l'environnement de travail, nous allons pouvoir entamer les choses sérieuses avec les bases du langage ![](images/logos/Rlogo.png).

## Les bases du langage ![](images/logos/Rlogo.png)

![](images/logos/Rlogo.png) est un langage de programmation. Il vous permet de communiquer avec votre ordinateur pour lui donner des tâches à accomplir. Dans cette section, nous allons couvrir les bases de ce langage.

### Hello World ! {#sect13}

Une introduction à un langage de programmation se doit de commencer par le rite de passage **Hello World**. Il s'agit d'une forme de tradition consistant à montrer aux nouveaux utilisateurs comment afficher le message "Hello World" à l'écran avec le langage en question.

En C, cela donne : 
```
#include <stdio.h>

main()
{
    printf("hello, world\n");
}
```
En COBOL : 
```
IDENTIFICATION DIVISION.
PROGRAM-ID. HELLO-WORLD.

ENVIRONMENT DIVISION.

DATA DIVISION.

PROCEDURE DIVISION.
    DISPLAY "Hello, world!".
    STOP RUN.
```

et plus simplement en ![](images/logos/Rlogo.png) :
```{r}
print("Hello World")
```

Bravo ! Vous venez officiellement de faire votre premier pas dans ![](images/logos/Rlogo.png) !

### Objets et expressions

Dans ![](images/logos/Rlogo.png), nous passons notre temps à manipuler des **objets** à l'aide d'**expressions**. Prenons un exemple concret, si vous tappez la syntaxe `4 + 3`, vous manipulez deux objets (4 et 3) au travers d'une expression indiquant que vous souhaitez obtenir la somme des deux objets.

```{r}
4 + 3
```

Cette expression est correcte, ![](images/logos/Rlogo.png) comprends vos indications et effectue le calcul.

Il est possible d'enregistrer le résultat d'une expression et de la conserver dans un nouvel objet. On appelle cette opération déclarer une variable.

```{r}
ma_somme <- 4 + 3
```

Concrêtement, nous venons de demander à ![](images/logos/Rlogo.png) d'enregistrer le résultat de `4 + 3` dans un espace spécifique de notre mémoire vive. Si vous regardez dans votre fenêtre **Environment**, vous verrez en effet qu'un objet appelé ma_somme est actuellement en mémoire et a pour valeur 7.

Notez ici que le nom des variables ne peut être composé que de lettres, de chiffres, de points (.) et de tiret bas (_) et doit commencer par une lettre. ![](images/logos/Rlogo.png) est sensible à la case, en d'autre termes, les variables `Ma_somme`, `ma_sommE`, `ma_SOMME`, et `MA_SOMME` renvoient toutes à un objet différent. Attention donc aux fautes de frappes. Si vous déclarez une variable en utilisant le nom d'une variable existante, la première est écrasée par la seconde : 

```{r}
age <- 35
age

age <- 45
age
```
Attention donc aux noms de variables que vous utilisez et réutilisez.


Réutilisons notre objet `ma_somme` dans une nouvelle expression : 

```{r}
ma_somme2 <- ma_somme + ma_somme
```

Avec cette nouvelle expression, nous indiquons à ![](images/logos/Rlogo.png) que nous souhaitons déclarer une nouvelle variable appelée `ma_somme2`, et que cette variable aura pour valeur `ma_somme + ma_somme`, soit `7 + 7`. Sans surprise, `ma_somme2` a pour valeur 14.

Notez que la mémoire vive (l'environnement) est vidée lorsque vous fermez ![](images/logos/Rlogo.png). En d'autres termes, ![](images/logos/Rlogo.png) perd complètement la mémoire lorsque vous le fermez. Vous pouvez bien sûr recréer vos objets en relançant les mêmes syntaxes. C'est pourquoi vous devez conserver vos feuilles de codes et ne pas seulement travailler dans la console. La console ne garde aucune trace de votre travail. Pensez donc bien à enregistrer votre code !

Nous verrons dans un autre chapitre comment sauvegarder des objets et les recharger dans une session ultérieure de ![](images/logos/Rlogo.png) (LIEN SECTION). Ce type d'opération est pertinente quand le temps de calcul nécessaire à la production de certains objets est très long.

### Fonctions et argument

Dans ![](images/logos/Rlogo.png), nous manipulons le plus souvent nos objets avec des **fonctions**. Une fonction est elle même un objet, mais qui a la particularité de pouvoir effectuer des opérations sur d'autres objets. Par exemple, déclarons l'objet `taille` avec une valeur de 175.897 : 

```{r}
taille <- 175.897
```

Nous allons utiliser la fonction `round` dont l'objectif est d'arrondir un nombre à virgule pour obtenir un nombre entier.

```{r}
round(taille)
```

Pour effectuer leurs opérations, les fonctions ont généralement besoin d'**arguments**. Ici, `taille` est un argument passé à la fonction `round`. Si nous regardons la documentation de `round` avec `help(round)`, nous constatons que cette fonction prend en réalité deux argments : *x* et *digits*. Le premier est le nombre que nous souhaitons arrondir et le second le nombre de décimales à conserver. On peut lire dans la documentation que la valeur par défaut de *digits* est 0, ce qui explique que `round(taille)` a produit le résultat de 176.

```{r fig011, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Arguments de la fonction round",  out.width='45%'}
knitr::include_graphics('images/introduction/help_round.jpeg', dpi = NA)
```

Réutilisons maintenant la fonction `round` mais en gardant une décimale : 

```{r}
round(taille, digits = 1)
```
Il est aussi possible que certaines fonctions ne requièrent pas d'arguments. Par exemple, la fonction `now` va indiquer la date précise (avec l'heure) et n'a besoin d'aucun argument pour le faire : 

```{r}
now()
```

Par contre, si nous essayons de lancer la fonction `round` sans argument, nous obtiendrons une erreur : 

```{r eval = FALSE}
round()
```
<span class = "error_message">Erreur : 0 arguments passed to 'round' which requires 1 or 2 arguments</span>

Le message est très clair, `round` a besoin d'au moins un argument pour fonctionner. Si au lieu d'un nombre, nous avions donné du texte à la fonction `round`, nous aurions aussi obtenu une erreur : 

```{r eval = FALSE}
round("Hello World")
```
<span class = "error_message">Error in round("Hello World") : 
  non-numeric argument to mathematical function</span>

À nouveau le message est très explicite : nous avons passé un argument non-numérique à une fonction mathématique. Lisez toujours vos messages d'erreurs qui vous permettront d'identifier des coquilles et de corriger votre code !

Une fonction essentielle est la fonction `print` qui permet d'afficher la valeur d'une variable.

```{r}
print(ma_somme)
```


### Principaux types de données

Depuis le début de ce chapitre, nous avons déclaré plusieurs variables et essentiellement des données numériques. Dans ![](images/logos/Rlogo.png), il existe trois principaux types de données de base : 

* Les données numériques, qui peuvent être des nombres entiers (appelés *integers*), ou des nombres décimaux (appelés *floats*), `15` et `15.3`.
* Les données textuelles, qui sont des chaînes de caratères (appelées *strings*) et déclarées entre guillemets `"abcdefg"`
* Les données booléennes (*booleans*) qui représentent les concepts de vrai (`TRUE`) ou de faux (`FALSE`).

Déclarons une variable pour chacun de ces types : 

```{r}
age <- 35
taille <- 175.5
adresse <- '4225 rue de la gauchetiere'
proprietaire <- TRUE
```

Notez également qu'il existe des types pour représenter l'absence de données : 

* pour représenter un objet vide, on utilisera l'objet `NULL`,
* pour représenter une données manquante, on utilisera l'objet `NA`,
* pour représenter un texte vide, on utilisera une chaîne de caractère de longueur 0 `""`.

```{r}
age2 <- NULL
taille2 <- NA
adresse2 <- ''
```

### Opérateurs

Nous avons vu que les fonctions nous permettent de manipuler des objets. Nous pouvons également effectuer un grand nombre d'opérations avec des opérateurs.

#### Opérateurs mathématiques

Les opérateur mathématiques permettent d'effectuer du calcul avec des données de type numérique.

Opérateur   |     Description   | Syntaxe      | Résultat  
----------- | ----------------- | ----------   | ---------
`+`         | Addition          | `4 + 4`      | 8
`-`         | Soustraction      | `4 - 3`      | 1
`*`         | Multiplication    | `4 * 3`      | 12
`/`         | Division          | `12 / 4`     | 3
`^`         | Exponentiel       | `4 ^ 3`      | 64
`**`        | Exponentiel       | `4 ** 3`     | 64
`%%`        | Reste de division | `15.5 %% 2`  | 1.5
`%/%`       | Division entière  | `15.5 %/% 2` | 7

#### Opérateur relationnels

Les opérateurs relationnels permettent de vérifier des conditions dans ![](images/logos/Rlogo.png). Ils renvoient un booléen, `TRUE` si la condition est vérifiée et `FALSE` si ce n'est pas le cas.

Opérateur   |     Description   | Syntaxe    | Résultat  
----------- | ----------------- | ---------- | ---------
`==`        | Égalité           | `4 == 4`   | TRUE
`!=`        | Différence        | `4 != 4`   | FALSE
`>`         | Est supérieur     | `5 > 4`    | TRUE
`<`         | Est inférieur     | `5 < 4`    | FAlSE
`>=`        | Est supérieur ou égal     | `5 >= 4`    | TRUE
`<=`        | Est inférieur ou égal     | `5 <= 4`    | FALSE

#### Opérateur logiques

Les opérateurs logiques permettent de combiner plusieurs conditions :

* L'opérateur **ET** permet de vérifier que deux conditions (l'une ET l'autre) sont TRUE. Si l'une des deux est FALSE, il renvoie FALSE.

* L'opérateur **OU** permet de vérifier que l'une des deux conditions est TRUE (l'une OU l'autre). Si les deux sont FALSE, alors il renvoit FALSE.

* L'opérateur **NOT** permet d'inverser une condition. Ainsi NOT TRUE est FALSE et NOT FALSE est TRUE.

Opérateur   |     Description   | Syntaxe    | résultat  
----------- | ----------------- | ---------- | ---------
`&`         | ET                | `TRUE & FALSE`   | FALSE
`|`         | OU        | `TRUE | FALSE`   | TRUE
`!`         | NOT     | `! TRUE`    | FALSE

Prenons le temps pour un rapide exemple : 

```{r}

a <- 4 
b <- 10
c <- -5

# produit TRUE car a est bien plus petit que b et c est bien plus petit que a
a < b & c < a

# produit FALSE car si a est bien plus petit que b, 
# b est en revanche plus grand que c
a < b & b < c

# produit TRUE car la seconde condition est inversée
a < b &  ! b < c

# produit TRUE car au moins une des deux conditions est juste
a < b |  b < c

```
Notez que l'opérateur **ET** est prioritaire sur l'opérateur **OU** et que les parenthèses sont prioritaires sur tous les opérateurs : 

```{r}
# produit TRUE car on va commencer par tester a < b ET b < c ce qui donne FALSE
# on obtient ensuite
# FALSE |  a > c
# enfin, a est bien supérieur à c, donc l'une des deux conditions est vraie
a < b & b < c |  a > c

```
Notez qu'en arrière plan, les opérateurs sont en réalité des fonctions déguisées. Il est donc possible de définir de nouveau comportements pour les opérateurs. Il est par exemple possible d'additionner ou comparer des objets spéciaux comme des dates, des géométries des graphes, etc.

### Structures de données

Jusqu'ici, nous avons travaillé avec des objets ne comprenant qu'une seule valeur. Lors d'une analyse statistique, nous allons travailler avec des volumes de données bien plus conséquents. Pour stocker plusieurs valeurs, nous allons travailler avec des structures de données que sont les vecteurs, les matrices, les *dataframes* et les listes.

#### Vecteurs

Les vecteurs sont la brique élémentaire de ![](images/logos/Rlogo.png). Ils permettent de stocker une série de valeur du même type dans une seule variable. Pour déclarer un vecteur, on utilise la fonction *c()* : 

```{r}
ages <- c(35,45,72,56,62)
tailles <- c(175.5,180.3,168.2,172.8,167.6)
adresses <- c('4225 rue de la gauchetiere','4223 rue de la gauchetiere','4221 rue de la gauchetiere','4219 rue de la gauchetiere','4217 rue de la gauchetiere')
proprietaires <- c(TRUE,TRUE,FALSE,TRUE,TRUE)
```

Nous venons ainsi de déclarer quatre nouvelles variables étant chacune un vecteur de longueur cinq (comprenant chacun cinq valeurs). Ces vecteurs représentent, par exemple, les réponses de plusieurs répondants à un questionnaire.

::: {.bloc_attention .bloc_attention_png data-latex="{blocs/attention}"}
Il existe dans ![](images/logos/Rlogo.png) une subtilité à l'origine de nombreux malentendus : la distinctions entre un vecteur de type texte et un vecteur de type facteur. Dans l'exemple précédent, le vecteur *adresses* est un vecteur de type texte. Chaque nouvelle valeur ajoutée dans le vecteur peut être n'importe quelle nouvelle adresse. Déclarons un nouveau vecteur qui contiendrait cette fois-ci la couleur des yeux de personnes ayant répondu au questionnaire.

```{r}
couleurs_yeux <- c('marron','marron','bleu','bleu','marron','vert')
```

Contrairement aux adresses, il y a un nombre limité de couleurs que nous pouvons mettre dans ce vecteur. Il serait intéressant de fixer les valeurs possibles du vecteur pour s'assurer que de nouvelles ne soient pas ajoutées par erreur. Pour cela, nous pouvons convertir ce vecteur texte en vecteur de type facteur avec la fonction `as.factor`.

```{r}
couleurs_yeux_facteur <- as.factor(couleurs_yeux)
```

Notez que à présent, nous pouvons ajouter une nouvelle couleur dans le 1er vecteur, mais pas dans le second.

```{r}
couleurs_yeux[7] <- "rouge"
couleurs_yeux_facteur[7] <- "rouge"
```
Le message d'erreur nous informe que nous avons tenté d'introduire une valeur invalide dans le facteur.

Les facteurs peuvent sembler restrictifs et très régulièrement, on préfère travailler avec de simples vecteurs de type texte plutôt que des facteurs. Cependant, de nombreuse fonctions d'analyse nécessitent d'utiliser des facteurs car ils assurent une certaine cohérence dans les données. Il est donc essentiel de savoir passer du texte au facteur avec la fonction `as.factor`. À l'inverse, il est parfois nécessaire de revenir par une variable de type texte avec la fonction `as.character`.

Notez que des vecteurs numériques peuvent aussi être convertis en facteur : 

```{r}
tailles_facteur <- as.factor(tailles)
```

Cependant, si vous souhaitez reconvertir ce facteur en format numérique, il faudra passer dans un premier temps par le format texte : 

```{r}
as.numeric(tailles_facteur)
```

Comme vous pouvez le voir, convertir un facteur en valeur numérique renvoie des nombres entiers. Ceci est du au fait que les valeurs dans un facteur sont recodées sous forme de nombres entiers, chaque nombre correspondant à une des valeurs originales (appelées niveaux). Si on convertit un facteur en valeurs numériques, on obtient donc ces nombres entiers.

```{r}
as.numeric(as.character(tailles_facteur))
```
Moralité de l'histoire, ne confondez pas les données de type texte et de type facteur. Dans le doute, vous pouvez demander à ![](images/logos/Rlogo.png) quel est le type d'un vecteur avec la fonction `class`.

```{r}
class(tailles)
class(tailles_facteur)
class(couleurs_yeux)
class(couleurs_yeux_facteur)
```
:::

Quasiment toutes les fonctions utilisent des vecteurs. Par exemple, on pourrait calculer la moyenne du vecteur *ages* en utilisant la fonction *mean* présente de base dans ![](images/logos/Rlogo.png).

```{r}
mean(ages)
```

Quand nous disons que le vecteur est la brique élémentaire de ![](images/logos/Rlogo.png), ce n'est pas juste une façon de parler. Toutes les variables que nous avons déclaré dans les sections précédentes sont aussi des vecteurs, mais de longueur 1 !

#### Matrices

Il est possible de combiner des vecteurs pour former des matrices. Une matrice est un tableau en deux dimensions (colonnes et lignes) généralement utilisé pour représenter certaines structures de données comme des images (pixels), effectuer du calcul matriciel ou plus simplement présenter des matrices de corrélations. Vous aurez rarement à travailler directement avec des matrices, mais il est bon de savoir ce qu'elles sont. Créons deux matrices à partir de nos précédents vecteurs.

```{r}
matrice1 <- cbind(ages,tailles)
# afficher la matrice 1
print(matrice1)
# afficher les dimensions de la matrice 1
print(dim(matrice1))

matrice2 <- rbind(ages, tailles)
# afficher la matrice 2
print(matrice2)
# afficher les dimensions de la matrice 2
print(dim(matrice2))
```
Comme vous pouvez le constater, la fonction `cbind` permet de concaténer des vecteurs comme s'ils étaient les colonnes d'une matrice, alors que `rbind` les combine comme s'ils étaient des lignes d'une matrice. La figure \@ref(fig:fig012) présente graphiquement le passage du vecteur à la matrice.

```{r fig012, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Du vecteur à la matrice",  out.width='30%'}
knitr::include_graphics('images/introduction/vecteur_to_matrix.png', dpi = NA)
```

Notez que vous pouvez transposer une matrice avec la fonction `t`. Si nous essayons maintenant de comparer la matrice 1 et la matrice 2 nous allons avoir une erreur car elles n'ont pas les mêmes dimensions.

```{r eval = FALSE}
matrice1 == matrice2
```
<span class="error_message">Error in matrice1 == matrice2 : non-conformable arrays</span>

En revanche, on pourrait transposer la matrice 1 et refaire cette comparaison : 

```{r}
t(matrice1) == matrice2
```

Le résultat souligne bien que l'on a les même valeurs dans les deux matrices. Il est aussi possible de construire des matrices directement avec la fonction `matrix`, ce que nous montrons dans la prochaine section.

#### *Arrays*

S'il est rare de travailler directement avec des matrices, il est encore plus rare de travailler avec des *arrays*. Un *array* est une matrice spéciale qui peut avoir plus que deux dimensions. Un cas simple serait un *array* en trois dimensions : lignes, colonnes, profondeur, que l'on pourrait se représenter comme un cube divisé en sous cubes. Au delà de trois dimensions, il devient difficile de se les représenter. Cette structure de données peut être utilisée pour représenter les différentes bandes spectrales d'une image sattelitaire. Les lignes et les colonnes délimiteraient les pixels de l'image, la profondeur quant à elle délimiterait les différents bandes composant l'image (figure \@ref(fig:fig012)).

```{r fig013, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Un array avec trois dimension",  out.width='15%'}
knitr::include_graphics('images/introduction/array.png', dpi = NA)
```

Créons un array en combinant trois matrices avec la fonction `array`. Chacune de ces matrices sera composée respectivement de 1, de 2 et de 3 et aura une dimension de 5 x 5. L'array final aura donc des dimensions de 5 x 5 x 3.

```{r}
mat1 <- matrix(1, nrow = 5, ncol = 5)
mat2 <- matrix(2, nrow = 5, ncol = 5)
mat3 <- matrix(3, nrow = 5, ncol = 5)

mon_array <- array(c(mat1, mat2, mat3), dim = c(5,5,3))

print(mon_array)
```


#### *DataFrames*

S'il est rare de manipuler des matrices et des *arrays*, le *DataFrame* (tableau de données en français) est la structure de données avec laquelle vous travaillerez le plus souvent.
Dans cette structure, chaque ligne du tableau représente un individu et chaque colonne représente une caractéristique de ces individus. Ces colonnes ont de noms, ce qui permet facilement d'accéder à leurs valeurs. Créons ensemble un *DataFrame* à partir de nos quatres vecteurs et de la fonction `data.frame`.

```{r}
df <- data.frame(
  "age" = ages,
  "taille" = tailles,
  "adresse" = adresses,
  "proprietaire" = proprietaires
)
```

```{r tabfirsttable, echo=FALSE, message=FALSE, warning=FALSE}
knitr::kable(
  df, booktabs = TRUE,
  caption = 'Un premier DataFrame'
)
```

Dans Rstudio, vous pouvez visualiser votre tableau de données avec la fonction `View(df)`. Comme vous pouvez le constater, chaque vecteur est devenu une colonne de votre tableau de données *df*. La figure \@ref(fig:fig014) résume ce passage d'une simple donnée à un DataFrame en passant par un vecteur.

```{r fig014, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="De la donnée au DataFrame",  out.width='25%'}
knitr::include_graphics('images/introduction/vecteur_to_dataframe.png', dpi = NA)
```

Plusieurs fonctions de base de ![](images/logos/Rlogo.png) fournissent des informations importantes sur un *DataFrame* : 

* `names` renvoie les noms des colonnes du DataFrame;
* `nrow` renvoie le nombre de lignes;
* `ncol` renvoie le nombre de colonnes.

```{r}
names(df)
nrow(df)
ncol(df)
```

Vous pouvez accéder à chaque colonne de *df* en utilisant le symbole `$` ou `[["nom_de_la_colonne"]]`. Recalculons ainsi la moyenne des âges :

```{r}
mean(df$age)
mean(df[["age"]])
```

#### Listes

La dernière structure de données à connaître est la liste. Elle liste ressemble à un vecteur, au sens où elle permet de stocker un ensemble d'objets les uns à la suite des autres. Cependant, une liste peut contenir n'importe quel type d'objets. Vous pouvez ainsi construire des listes de matrices, des listes d'*arrays*, des listes de listes, des listes mixant des vecteurs, des graphiques, des *DataFrames*, etc.

Créons ensemble une liste qui va contenir des vecteurs et des matrices à l'aide de la fonction `list.`

```{r}
ma_liste <- list(c(1,2,3,4),
                 matrix(1, ncol = 3, nrow = 5),
                 matrix(5, ncol = 3, nrow = 7),
                 'A'
                 )
```

Il est possible d'accéder aux éléments de la liste par leur position dans cette dernière en utilisant les doubles crochets `[[ ]]`: 

```{r}
print(ma_liste[[1]])
print(ma_liste[[4]])
```

Il est aussi possible de donner des noms aux éléments de la liste et d'utiliser le symbole `$` pour y accéder. Créons une nouvelle liste de vecteurs et donnons leurs des noms avec la fonction `names`.

```{r}
liste2 <- list(c(35,45,72,56,62), 
               c(175.5,180.3,168.2,172.8,167.6),
               c(TRUE,TRUE,FALSE,TRUE,TRUE)
)
names(liste2) <- c("age",'taille','proprietaire')

print(liste2$age)
```

Si vous avez bien suivi, vous devez avoir compris qu'un *DataFrame* n'est en fait rien d'autre qu'une liste de vecteurs avec des noms !

Bravo ! Vous venez de faire le tour des bases du langage ![](images/logos/Rlogo.png). Nous allons pouvoir passer à la suite et apprendre à manipuler des données dans des *DataFrames* !

## Manipuler des données

Dans cette section, nous allons apprendre à charger et manipuler des DataFrame en vue d'effectuer des opérations classiques de gestion de données.

### Charger un DataFrame depuis un fichier

Il sera rarement nécessaire de créer vos DataFrame à la main comme nous L'avons fait dans la section précédente. Le plus souvent, vous disposerez de fichiers contenant vos données et certaines fonctions vous permettrons de les importer dans ![](images/logos/Rlogo.png) directement sous forme d'un DataFrame. Les formats les plus répandus sont : 

* .csv, il s'agit d'un fichier texte dont chaque ligne représente une ligne du tableau de données dont les colonnes sont séparées par un délimiteur (généralement une virgule ou un point-virgule).
* .dbf, ou fichier dBase, souvent associés à des fichiers d'information géographique ShapeFile,
* .xls et .xlsx, des fichiers générés par Excel
* .json, il s'agit d'un ficher texte utilisant une norme d'écriture propre au langage JavaScript.

Plus rarement, il se peut que vous ayez à charger des fichiers provenant de logiciels concurrents à ![](images/logos/Rlogo.png) : 

* .sas7bdat, provenant du logiciel SAS,
* .sav, provenant du logiciel SPSS,
* .dta, provenant du logiciel STATA.

Pour lire la plupart de ces fichiers, nous allons utiliser le *package* **foreign**, qui a été développé à cette fin. Commencez donc par l'installer. Si vous ne vous souvenez plus comment faire, faites un tour à la section X.

Nous allons chagrer cinq fois le même jeu de données qui a été enregistré au format csv, dbf, dta, sas7bdat et xlsx. Nous allons également enregistrer le temps nécessaire pour lire chacun de ces fichiers avec la fonction `Sys.time`.

#### Lire un fichier csv

Pour le format csv, il n'y a pas besoin d'utiliser un *package* externe, ![](images/logos/Rlogo.png) dispose d'une fonction de base pour lire ce format.

```{r message=FALSE, warning=FALSE}
t1 <- Sys.time()
df1 <- read.csv("data/priseenmain/SR_MTL_2016.csv", 
         header = TRUE, sep = ",", dec = ".",
         stringsAsFactors = FALSE)
t2 <- Sys.time()
d1 <- difftime(t2,t1,units="secs")

cat('le dataframe df1 a ',nrow(df1),' observations\n')
cat('les colonnes de df1 sont : ',names(df1),"\n")
```

rien de bien compliqué, notez tout de même que : 

* Lorsque vous chargez un fichier csv, vous devez connaître le **séparateur**, il s'agit du caractère utilisé pour délimiter les colonnes de votre csv. Dans notre cas il s'agit d'une simple virgule : ",", mais ça pourrait tout aussi bien être un point virgule ";" une tabulation "    " etc.
* Vous devez également connaître le symbole utilisé pour le décimales. Neuf fois sur dix, ce sera le point ".", mais il se peut que certains logiciel en configuration française vous exportes des fichers csv avec des virgules "," comme symbole de décimale.
* Le paramètre *header* indique si la première ligne (l'entête) du fichier comprend les noms des colonnes du jeu de données. Il arrive que certains fichiers csv soient fournis sans entête, avec le nom et la description des colonnes dans un fichier à part.
* Le paramètre *stringsAsFactors* permet d'indiquer à ![](images/logos/Rlogo.png) que les colonnes comportant du texte doivent être chargées comme des vecteurs de type texte et nom de type facteur. Nous reviendrons sur cette distinction dans la section XXX.

#### Lire un fichier dbase

Pour lire un fichier dbase (.dbf), nous allons devoir utiliser le *package* foreign que nous avons installé précédemment : 

```{r message=FALSE, warning=FALSE}
library(foreign)

t1 <- Sys.time()

df2 <- read.dbf("data/priseenmain/SR_MTL_2016.dbf")

t2 <- Sys.time()
d2 <- difftime(t2,t1,units="secs")

cat('le dataframe df2 a ',nrow(df2),' observations\n')
cat('les colonnes de df2 sont : ',names(df2),"\n")
```
Comme vous pouvez le constater, nous obtenons exactement les mêmes résultats qu'avec le fichier csv

#### Lire un fichier dta

Si vous travaillez avec des collègues utilisant le logiciel STATA, il se peut que ces derniers vous partagent des fichiers dta. En utilisant à nouveau le *package* **foreign**, vous serez en mesure de les charger directement dans ![](images/logos/Rlogo.png).

```{r message=FALSE, warning=FALSE}
t1 <- Sys.time()

df3 <- read.dta("data/priseenmain/SR_MTL_2016.dta")

t2 <- Sys.time()
d3 <- difftime(t2,t1,units="secs")

cat('le dataframe df3 a ',nrow(df3),' observations\n')
cat('les colonnes de df3 sont : ',names(df3),"\n")
```

#### Lire un fichier sas7bdat

De même, il existe de nombreux milieux où le logiciel SAS est très utilisé. Si l'on vous partage un fichier sas7bdat, vous pourrez l'ouvrir avec le *package* **sas7bdat**

```{r message=FALSE, warning=FALSE}
library(sas7bdat)
t1 <- Sys.time()

df4 <- read.sas7bdat("data/priseenmain/SR_MTL_2016.sas7bdat")

t2 <- Sys.time()
d4 <- difftime(t2,t1,units="secs")

cat('le dataframe df4 a ',nrow(df4),' observations\n')
cat('les colonnes de df4 sont : ',names(df4),"\n")
```

#### Lire un fichier xlsx

Lire un fichier excel dans ![](images/logos/Rlogo.png) n'est pas une chose facile. Généralement, nous recommandons d'exporter les fichiers en question au format csv dans un premier temps. Il est cependant possible de directement lire un fichier xlsx avec le *package* **xlsx**. Ce dernier requiert que le logiciel JAVA soit installé sur votre ordinateur (Windows, Mac ou Linux). Si vous utilisez la version 64 bit de ![](images/logos/Rlogo.png), vous devrez télécharger et installer la version 64 bit de JAVA. Une fois que ce logiciel tiers est installé, il ne vous reste plus qu'à installer le *package* **xlsx** (`install.packages("xlsx")`) et à le charger.

```{r message=FALSE, warning=FALSE}
library(xlsx)

t1 <- Sys.time()

df5 <- read.xlsx("data/priseenmain/SR_MTL_2016.xlsx",sheetIndex = 1,
                 as.data.frame = TRUE)

t2 <- Sys.time()
d5 <- difftime(t2,t1,units="secs")


cat('le dataframe df5 a ',nrow(df5),' observations\n')
cat('les colonnes de df5 sont : ',names(df5),"\n")
```

Il est possible de nettement accelérer la vitesse de lecture d'un fichier xlsx en utilisant la fonction `read.xlsx2`. Il faut cependant indiquer à cette dernièere le type de données que l'on doit trouver dans chaque colonne. Dans le cas présent, nous savons que les 5 premières colonnes contiennent des données au format texte (character), alors que les 43 autres sont des données numériques (numeric). Pour ces dernières, nous allons utiliser la fonction `rep` afin de ne pas avoir à écrire 43 fois le mot numeric.

```{r message=FALSE, warning=FALSE}
library(xlsx)

t1 <- Sys.time()

df6 <- read.xlsx2("data/priseenmain/SR_MTL_2016.xlsx",sheetIndex = 1, 
                  as.data.frame = TRUE,
                  colClasses = c("character","character","character","character","character",rep("numeric",43)))

t2 <- Sys.time()
d6 <- difftime(t2,t1,units="secs")

cat('le dataframe df6 a ',nrow(df6),' observations\n')
cat('les colonnes de df6 sont : ',names(df6),"\n")
```

Si l'on compare les temps d'exécution du tableau \@ref(tab:tableduration), on constate que la lecture des fichiers xlsx peut être extrèmement longue si l'on ne spécifie pas le type des colonnes. Ceci peut devenir un problème majeur pour des fichier volumineux. Notez également que la lecture des fichiers csv devient de plus en plus laborieuse à mesure que la taille du fichier csv augment. Si vous devez un jour charger des fichiers csv de plusieurs giga octets, nous vous recommandons d'utiliser la fonction `fread` du *package* **data.table** qui est beaucoup plus rapide.

```{r tableduration, message=FALSE, warning=FALSE}

durations <- data.frame(
  "duree" = c(d1,d2,d3,d4,d5,d6),
  "fonction" = c("read.csv","read.dbf","read.dta",
                 'read.sas7bdat',"read.xlsx","read.xlsx2")
)

knitr::kable(
  durations, booktabs = TRUE,digits = 2,
  col.names = c("Durée (s)","fonction"),
  caption = 'Temps nécessaire pour lire les données en fonction du type de fichier'
)

```
### Manipuler un DataFrame

Maintenant que nous savons comment charger un DataFrame, nous allons apprendre à les manipuler.

#### Un petit mot sur le tidyverse

Avant d'aller plus loin, il est important d'introduire brièvement un débat actuel dans la communauté ![](images/logos/Rlogo.png). Depuis entre 2010 et 2020 s'est peu à peu imposé sur le devant de la scène le *package* **tidyverse**. Plus exactement, **tidyverse** est un ensemble de *packages*, pensés pour faciliter la structuration et la manipulation des données dans ![](images/logos/Rlogo.png). Développé et maintenu par Hadley Wickham, ce *package* introduit une philosophie et une grammaire spécifiques, qui diffèrent du langage ![](images/logos/Rlogo.png) traditionnel. Une partie de la communauté a pour ainsi dire complètement embracé le **tidyverse** et de nombreux *packages* en dehors du **tidyverse** ont adopté sa grammaire et sa philosophie. À l'inverse, une autre partie de la communauté est [opposée](https://blog.ephorie.de/why-i-dont-use-the-tidyverse) à cette évolution. On peut résumer les arguments des deux partis avec le tableau suivant : 

Avantages du **tidyverse** | Problèmes posés par le **tidyverse**
-------------------------- | ------------------------------------ 
Simplicité d'écriture et d'apprentissage | Nouvelle syntaxe à apprendre
Ajout de l'opérateur %>% permettant d'enchaîner les traitements | Perte de lisibilité avec l'opérateur ->
La meilleure librairie pour réaliser des graphiques : **ggplot2** | Certaines fonctions de base sont remplacées par **tidyverse** lors de son chargement, pouvant créer des bugs.
Crée un écosystème cohérent | Rajoute une dépendance dans le code
Package en développement et de plus en plus utilisé  | Philosophie d'évolution aggressive, aucune assurance de rétro-compatibilité

Le dernier point est probablement le plus problématique. Dans sa volonté d'évoluer au mieux et sans restriction, le *package* **tidyverse** n'offre aucune garantie de rétro-comptatibilité. En d'autre termes, des changements importants peuvent être introduit d'une version à l'autre rendant potentiellement obsolète votre propre code.

Nous n'avons pas d'opinion tranchée sur le sujet. **tidyverse** est un outil très intéressant dans de nombreux cas. Nous évitons simplement de l'utiliser en permanence et préférons charger directement les sous-packages (comme **dplyr** ou **ggplot2**) du **tidyverse** dont nous avons besoin.

Notez que le *package* **data.table** offre une alternative au **tidyverse** dans la manipulation de données. Au prix d'un syntaxe généralement un peu plus complexe **data.table** offre une vitesse de calcul bien supérieure au **tidyverse** et assure une bonne rétro-compatibilité.


#### Gérer les colonnes d'un DataFrame

Repartons du DataFrame que nous avions chargé précédemment grâce à un fichier csv.

```{r message=FALSE, warning=FALSE}
df <- read.csv("data/priseenmain/SR_MTL_2016.csv", 
         header = TRUE, sep = ",", dec = ".",
         stringsAsFactors = FALSE)
```

##### Sélectionner une colonne
Pour rappel, il est possible d'accéder aux colonnes dans ce DataFrame en utilisant le symbole dollar `$ma_colonne` ou les doubles crochets `[["ma_colonne"]]`

```{r message=FALSE, warning=FALSE}
#calcul de la superficie totale de l'Île de Montréal
sum(df$KM2)
sum(df[["KM2"]])
```

##### Sélectionner plusieurs colonnes
Il est possible de sélectionner plusieurs colonnes d'un DataFrame. On peut ainsi filtrer des colonnes inutiles. Pour cela, on peut utiliser un vecteur contenant la position de la colonne (1 pour la première colonne, 2 pour la seconde et ainsi de suite), ou un vecteur contenant le nom des colonnes.

```{r message=FALSE, warning=FALSE}
#garder les 5 premières colonnes
df2 <- df[1:5]

#garder les colonnes 1,5,10 et 15
df3 <- df[c(1,5,10,15)]

#garder les colonnes 1 à 5, 7 à 12, 17 et 22
df4 <- df[c(1:5,7:12,17,22)]

#garder les colonnes avec leurs noms
df5 <- df[c("SRIDU","KM2","Pop2016","MaisonIndi","LoyerMed")]

```

##### Supprimer des colonnes
Il peut être plus intéressant de directement supprimer des colonnes plutôt que de recréer un nouveau DataFrame. Pour cela, on va attribuer la valeur `NULL` à ces colonnes

```{r message=FALSE, warning=FALSE}
#supprimer le colonnes 2,3 et 5
df3[c(2,3,5)] <- list(NULL)

#supprimer une colonne avec son nom
df4$OID <- NULL

#supprimer des colonnes par leur nom
df5[c("SRIDU","LoyerMed")] <- list(NULL)
```
Notez que si vous supprimez une colonne, vous ne pouvez pas revenir en arrière. Il faudra recharger votre jeu de données ou relancer les calculs qui avaient produit cette colonne.

##### Renommer des colonnes
Il est possible de changer le nom d'un colonne. Cette opération est importante pour faciliter la lecture du DataFrame ou s'assurer que l'on n'aura pas de problème lorsque l'on exportera le DataFrame dans un fichier.

```{r message=FALSE, warning=FALSE}
#voici les anciens noms
names(df5)

#renommer toutes les colonnes
names(df5) <- c('superficie_km2','population_2016', 'maison_individuelle_prt')
names(df5)

#renommer avec dplyr
library(dplyr)
df4 <- rename(df4, "population_2016" = "Pop2016",
              "prs_moins_14ans_prt" = "A014",
              "prs_15_64_ans_prt" = "A1564",
              "prs_65plus_ans_prt" = "A65plus"
              )
```


#### Opérateurs mathématique

Il est possible d'utiliser les colonnes de type numérique pour calculer de nouvelles colonnes en utilisant les opérateurs mathématiques vus dans la section X.

Prenons un exemple concret et calculons la densité de population par secteur de recensement dans notre précédent DataFrame et affichons un résumé de cette nouvelle variable.

```{r message=FALSE, warning=FALSE}

# calcul de la densité
df$pop_density_2016 <- df$Pop2016 / df$KM2

summary(df$pop_density_2016)
```

Nous pouvons aussi calculer le ratio entre le nombre de maisons et le nombre d'appartements.

```{r message=FALSE, warning=FALSE}

# calcul de la densité
df$total_maison <- (df$MaisonIndi + df$MaisJumule + df$MaisRangee + df$AutreMais)
df$total_apt <- (df$AppDuplex + df$App5Moins + df$App5Plus)
df$ratio_maison_apt <- df$total_maison / df$total_apt

summary(df$ratio_maison_apt)
```

Ce qu'il faut retenir ici, c'est que ![](images/logos/Rlogo.png) va appliquer le calcul à chaque ligne de votre jeu de données et stocker le résultat dans une nouvelles colonne. On appelle cela du calcul vectoriel : toute la colonne est calculée en une seule fois. ![](images/logos/Rlogo.png) est optimisé pour faire du calcul vectoriel.

#### fonctions mathématique

![](images/logos/Rlogo.png) propose un ensemble de fonctions de base pour effectuer du calcul. Voici une liste des principales fonctions (non-exhaustive) : 

* `abs` : calcule les valeurs absolue des valeurs d'un vecteur
* `sqrt` : calcule les racines carrés des valeurs d'un vecteur
* `log` : calcule les logarithmes des valeurs d'un vecteur
* `exp` : calcule les exponentiels des valeurs d'un vecteur
* `factorial` : calcule la factorielle des valeurs d'un vecteur
* `round` : arrondit les valeurs d'un vecteur
* `ceiling`, `floor` : arrondit à l'unité supérieure ou inférieure les valeurs d'un vecteur
* `sin`,`asin`,`cos`,`acos`,`tan`,`atan` : les fonctions de trigonométrie classiques
* `cumSum` : calcule la somme cumulative des valeurs d'un vecteur

Ces fonctions sont des fonctions vectorielles. Elles s'appliquent à tous les éléments d'un vecteur. Si votre vecteur en entrée comprends 5 valeurs, le vecteur en sortie comprendra 5 valeurs également.

À l'inverse, les fonctions suivantes s'appliquent directement à l'ensemble d'un vecteur et ne vont renvoyer qu'une seule valeur.

* `sum` : calcule la somme des valeurs d'un vecteur
* `prod` : calcule le produit des valeurs d'un vecteur
* `min`, `max` : renvoit les valeurs maxmimales et minimale d'un vecteur
* `mean`, `median` : renvoit la moyenne et la médiane d'un vecteur
* `quantile` : renvoit les percentiles d'un vecteur

#### fonctions pour manipuler du texte

En plus des données numérique, vous aurez à travailler avec des données textuelles. Le **tidyverse** avec le *package* **stringr** offre des fonctions très intéressantes pour manipuler ce type de donnée. Pour un aperçu de toutes les fonctions offertes par **stringr**, vous pouvez référer à sa [Cheat Sheet](https://github.com/rstudio/cheatsheets/blob/master/strings.pdf). Commençons avec un DataFrame assez simple comprenant des adresses et des noms de personnes.

```{r message=FALSE, warning=FALSE}
library(stringr)

df <- data.frame(
  noms = c("Liliana ford","faram mcclure","shanice Howells","Nella Cardenas"),
  adresses = c('152 rue Levy', '4138 Blvd René-Lévesque', '3606 rue Duké', '2457 route St Marys')
)
```

##### Majuscules et minuscules

Pour harmoniser ce dataframe, nous allons dans un 1er temps harmoniser les majuscules des noms des individus avec la fonction `str_to_title`.

```{r message=FALSE, warning=FALSE}
df$noms_corr <- str_to_title(df$noms)
print(df$noms_corr)
```

On pourrait également tout mettre en minuscule ou tout en majuscule.
```{r message=FALSE, warning=FALSE}
df$noms_min <- tolower(df$noms)
df$noms_maj <- toupper(df$noms)
print(df$noms_min)
print(df$noms_maj)
```

##### Remplacer du texte

Dans les adresses, nous avons des caractères accentués. Ce type de caractère pose régulièrement des problèmes d'encodage et nous pourrions décider de les remplacer par des caractères simples avec la fonction `str_replace_all`.

```{r message=FALSE, warning=FALSE}
df$adresses_1 <- str_replace_all(df$adresses,'é','e')
print(df$adresses_1)
```

Nous pouvons utiliser la même fonction pour remplacer les *St* par Saint et les *Blvd* par Boulevard.

```{r message=FALSE, warning=FALSE}
df$adresses_2 <- str_replace_all(df$adresses_1,' St ',' Saint ')
df$adresses_3 <- str_replace_all(df$adresses_2,' Blvd ',' Boulevard ')
print(df$adresses_3)
```

##### Découper du texte

Il est parfois nécessaire de découper du texte pour en extraire des éléments. On doit alors choisir un caractère de découpage. Dans notre cas, on pourrait vouloir extraire les numéros civiques des addresse, en utilisant le premier espace comme caractère de découpage. Ce qui est faisables avec la fonction `str_split_fixed`.

```{r message=FALSE, warning=FALSE}
df$num_civique <- str_split_fixed(df$adresses_3, ' ',n=2)[,1]
```

Pour être exact, sachez que dans notre example, la fonction `str_split_fixed` renvoie deux colonnes de texte : une avec le texte avec le 1er espace (donc le numéros civique) et une avec le reste du texte. Le nombre de colonne est contrôlé par l'argument `n`. Si `n = 1`, la fonction ne fait aucun découpage, avec `n = 2` la fonction va découper en deux partie le texte avec la première occurence du délimiteur, et ainsi de suite.  En ajoutant `[,1]` à la fin, nous indiquons que nous souhaitons seulement garder la 1ère des deux colonnes.

##### Coller du texte

À l'inverse du découpage, il est parfois nécessaire de coller ensemble des éléments de texte, ce que nous pouvons faire avec la fonction `paste`.

```{r message=FALSE, warning=FALSE}
df$texte_complet <- paste(df$noms_corr, df$adresses_3, sep = " : ")
print(df$texte_complet)
```

Le paramètre `sep` permet de choisir les caractères à intercaler entre les éléments à coller. Notez qu'il est possible de coller plus que deux éléments ensembles : 

```{r message=FALSE, warning=FALSE}
df$ville <- c('Montreal','Montreal','Montreal','Montreal')
paste(df$noms_corr, df$adresses_3, df$ville, sep = "  ")
```

#### Manipuler des colonnes de type date

Nous avons vu que les principaux types de données dans ![](images/logos/Rlogo.png) sont le numérique, le textuel, le booléen et le facteur. Il existe de types supplémentaires, introduit par différent packages. Nous introduisons ici les types date et temps (date and time), qui permettent de représenter des moments et des durées. Pour les manipuler, nous avons une préférence pour le *package* **lubridate** du **tidyverse**. Nous allons travailler avec un jeu de données ouvertes de la ville de Montréal représentant les accidents de la route incluant au moins un vélo aprés le premier janvier 2017.

```{r message=FALSE, warning=FALSE}
accidents_df <- read.csv("data/priseenmain/accidents.csv",
                         sep = ",")
names(accidents_df)
```

Nous avons donc trois colonnes, la première représentant l'heure de l'accident, la seconde la date de l'accident et la dernière le nombre de victime.

##### Du texte à la date

Actuellement, les colonnes *HEURE_ACCDN* et *DT_ACCDN* sont au format texte. Nous pouvons afficher quelques lignes du jeu de données avec la fonction `head` pour voir comment elles ont été saisies.

```{r message=FALSE, warning=FALSE}
head(accidents_df, n = 5)
```

Nous avons un peu de nettoyage à faire : les heures sont indiquées comme des préiode de une heure. Nous allons utiliser la fonction str_split_fixed du *package* **stringr** vue précédemment pour ne garder que la première partie de l'heure (avant le tiret). Nous allons ensuite concaténer l'heure et la date avec la fonction `paste`, puis nous pourrons convertir l'ensemble en un objet date-time.

```{r message=FALSE, warning=FALSE}
library(lubridate)

# étape 1 : découper la colonne Heure_ACCDN
accidents_df$heure <- str_split_fixed(accidents_df$HEURE_ACCDN, "-", n=2)[,1]

# étape 2 : concaténer l'heure et la date
accidents_df$date_heure <- paste(accidents_df$DT_ACCDN, 
                                 accidents_df$heure,
                                 sep = ' ')

# étape 3 : convertir au format datetime
accidents_df$datetime <- as_datetime(accidents_df$date_heure,
                                     format = "%Y/%m/%d %H:%M:%S")
```

Pour effectuer la conversion, nous avons utilisé la fonction `as_datetime` du package **lubridate**. Elle prend comme paramètre un vecteur de texte et une indication du format de ce vecteur de texte. En effet, il y a de nombreuses façon de spécifier une date et une heure et l'argument *format* permet de spécifier quelle nomenclature nous utilisons. Dans notre cas une date est structurée ainsi : 
`année/mois/jour heure:minute:seconde`, ce qui se traduit par le format `%Y/%m/%d %H:%M:%S`.

* %Y signifie une année indiquée avec 4 caractères : 2017
* %m signifie un mois, indiqué avec deux caractères : 01, 02, 03, ... 12
* %d signifie un jour, indiqué avec deux caractères : 01, 02, 03, ... 31
* %H signifie une heure, au format 24 heures avec deux caractères : 00, 02, ... 23
* %M signifie des minutes indiquées avec deux caractères : 00, 02, ... 59
* %S signifie des secondes, indiquées avec deux caractères : 00, 02, ... 59

Notez que les caractères séparant les années, jours, heures, etc. sont aussi à indiquer dans le format. Dans notre cas, nous utilisions des `/` pour séparer les éléments de la date, des `:` pour l'heure, et un espace pour séparer la date et l'heure.

Il existe d'autre nomenclatures pour spécifier un format *datetime* si vous avez par exemple des mois renseignés par leur nom, l'indication AM-PM, etc. Vous pouvez vous référez à la documentation de la fonction `strptime` (`help(strptime)`) pour trouver toutes les nomenclatures. Bien évidemment, il est **nécessaire** que toutes les dates de votre colonne soient renseignées dans le même format. Sinon, la fonction renverra des valeurs `NA` aux endroits où elle a échoué à lire le format.

Après toutes ces opérations, rejettons un oeil à notre *DataFrame*.

```{r message=FALSE, warning=FALSE}
head(accidents_df, n = 5)
```
##### Extraire des informations d'une date

Avec notre nouvelles colonne `datetime`, nous sommes en mesure d'extraire des informations intéressantes comme : 

Le nom du jour de la semaine avec la fonction `weekdays`
```{r message=FALSE, warning=FALSE}
accidents_df$jour <- weekdays(accidents_df$datetime)
```

La période de la journée avec les fonctions `am` et `pm` 
```{r message=FALSE, warning=FALSE}
accidents_df$AM <- am(accidents_df$datetime)
accidents_df$PM <- pm(accidents_df$datetime)

head(accidents_df[c("jour", "AM", "PM")], n=5)
```

Il est aussi possible d'accéder aux sous éléments d'un datetime année, mois, jour, heure, minute, seconde avec les fonctions `year()`, `month()`,`day()`, `hour()`,  `minute()` et `second()`.

##### Calculer une durée entre deux datetime

Une autre utilisation intéressante du format datetime est de calculer des différences de temps. Par exemple, nous pourrions utiliser le nombre de minutes écoulées depuis 07:00 AM comme une variable dans une analyse visant à déterminer le moment critique des accidents durant l'heure de point du matin.

Pour cela, nous devons créer un datetime de référence en concaténant la date de chaque observation, et le temps 07:00:00 qui sera notre point de départ.

```{r message=FALSE, warning=FALSE}
accidents_df$date_heure_07 <- paste(accidents_df$DT_ACCDN, 
                                 '07:00:00',
                                 sep = ' ')
accidents_df$ref_datetime <- as_datetime(accidents_df$date_heure_07,
                                     format = "%Y/%m/%d %H:%M:%S")
```
Il ne nous reste plus qu'à calculer la différence de temps entre la vrai colonne *datetime* et notre temps de référence *ref_datetime*.

```{r message=FALSE, warning=FALSE}
accidents_df$diff_time <- difftime(accidents_df$datetime,
                                   accidents_df$ref_datetime,
                                   units = 'min')
```

Notez qu'ici la colonne *diff_time* est d'un type spécial : une différence temporelle (difftime). Il faut encore la convertir au format numérique pour pour voir l'utiliser avec la fonction `as.numeric`.

Pour le plaisir, réalisons rapidement un histogramme avec la fonction `hist` pour regarder cette variable d'écart de temps !

```{r fig015, fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), auto_pdf = TRUE, fig.cap="Répartition temporelle des accidents à vélo",  out.width='65%'}

accidents_df$diff_time_num <- as.numeric(accidents_df$diff_time)

hist(accidents_df$diff_time_num, breaks = 50)

```

On observe clairement deux pics, un premier entre 0 et 100 (donc entre 07:00 08:30 environ) et un second plus important entre 550 et 650 (entre 16:00 et 17:30 environ) ce qui correspond sans surprise aux heures de points. Il est intéressant de noter que plus d'accidents se produisent à l'heure de pointe du soir.

#### Recoder des variables

Recoder des variables signifie changer la valeur d'une variable selon une condition afin d'obtenir une nouvelle variable. Si nous reprenons notre example précédent avec les accidents à vélo, nous pourrions créer une nouvelle colonne nous indiquant si l'accident a eu lieu en heure de pointe ou hors heure de pointe. On obteniendrait ainsi une nouvelle variable avec seulement deux catégories, plutôt que la variable numérique originale. Nous pourrions aussi définir quatre cas avec l'heure de pointe du matin, l'heure de pointe du soir, le reste de la journée et la nuit.

##### Le cas binaire avec ifelse

Si l'on ne souhaite créer que deux catégorie, le plus simple est de passer par la fonction `ifelse`. Cette fonction va évaluer une condition (SECTIOn X) pour chaque ligne d'un DataFrame et produir un nouveau vecteur. Créons donc une variable binaire indiquant si un accident a eu lieu en heure de pointe ou hors heure de pointe. Nous allons devoir évaluer les conditions suivantes : 

Est-ce que l'accident a eu lieu entre 07:00 (0) **ET** 09:00 (120), **OU** est ce que l'accident a eu lieu entre 16:30 (570) **ET** 18:30 (690).

```{r message=FALSE, warning=FALSE}
Cond1 <- accidents_df$diff_time_num >= 0 & accidents_df$diff_time_num <= 120
Cond2 <- accidents_df$diff_time_num >= 570 & accidents_df$diff_time_num <= 690

accidents_df$moment_bin <- ifelse(Cond1 | Cond2,
                                  "en heure de pointe",
                                  "hors heure de point")
```

Comme vous pouvez le constater, la fonction `ifelse` nécessite trois arguments : 

* Une condition, pouvant être `TRUE` ou `FALSE`,
* La valeur à renvoyer si la condition est `TRUE`
* La valeur à renvoyer si la condition est `FALSE`

Avec la fonction `table`, nous pouvons rapidement compter le nombre de résultat dans chaque catégorie : 

```{r message=FALSE, warning=FALSE}
table(accidents_df$moment_bin)
```
Les heures de pointes représentent quatre heures de la journée, ce qui nous laisse neuf heures hors heure de pointe entre 07:00 et 20:00.

```{r message=FALSE, warning=FALSE}
# ration d'accident en heure de pointe
(841 / 2414) / (4 / 13)

#ration d'accident hors heure de point
(1473 / 2414) / (9 / 13)
```
En rapportant les accidents au durée des deux période, on observe une sur-représentation des accidents impliquant un vélo pendant les heures de points d'environs 13% comparativement au périodes hors des heures de pointes.

##### Le cas multiple avec la fonction case_when

Lorsque l'on souhaite créer plus que deux catégories, il est possible soit d'enchaîner plusieurs fonctions `ifelse` (ce qui produit un code plus long et moins lisible), soit d'utiliser la fonction `case_when` provenant du *package* **dplyr** du **tidyverse**. Reprenons notre example précédent et créons quatre catégories : 

* En heure de pointe du matin
* En heure de pointe du soir
* Le reste de la journée (entre 07:00 et 20:00)
* De nuit (entre 21:00 et 07:00)

```{r message=FALSE, warning=FALSE}
library(dplyr)

accidents_df$moment_multi <- case_when(
  accidents_df$diff_time_num >= 0 & accidents_df$diff_time_num <= 120 ~ "pointe AM",
  accidents_df$diff_time_num >= 570 & accidents_df$diff_time_num <= 690 ~ "pointe PM",
  accidents_df$diff_time_num > 690 & accidents_df$diff_time_num < 780 ~ "journee",
  accidents_df$diff_time_num > 120 & accidents_df$diff_time_num < 570 ~ "journee",
  accidents_df$diff_time_num < 0 | accidents_df$diff_time_num >= 780 ~ "nuit"
)

table(accidents_df$moment_multi)
```
La syntaxe de cette fonction est un peu particulière. Elle accepte un nombre illimité d'argument. Chaque argument est composé d'une condition, et d'une valeur à renvoyer si la condition est vrai, ces deux éléments étant relié par le symbole `~`. Notez que toutes les évaluations sont effectuées dans l'odre des arguments. En d'autres termes, la fonction va d'abord tester la première condition et assigner ces valeurs, puis recommencer pour les prochaines conditions. Ainsi, si une une même observation (ligne du tableau de données) obtient `TRUE` à plusieurs conditions, elle obtiendra la valeur de la dernière condition qu'elle a validée.

#### Sous sélection d'un DataFrame

Dans cette section, nous allons explorer comme extraire des sous-parties d'un *DataFrame*. Il est possible de sous-sélectionner des lignes et des colonnes en se basant sur des conditions ou leurs index. Pour cela, nous allons utiliser un jeu de données fourni avec ![](images/logos/Rlogo.png) : le jeu de données **iris** décrivant des fleurs du même nom.

```{r message=FALSE, warning=FALSE}
data("iris")
dim(iris)
```
##### Sous-sélectionner des lignes

Sous sélectionner des lignes par index est relativement facile. Admettons que nous souhaitons sélectionner les lignes 1 à 5, 10 à 25, 37 et 58.

```{r message=FALSE, warning=FALSE}
sub_iris <- iris[c(1:5, 10:25, 37, 58),]
nrow(sub_iris)
```
Sous sélectionner des lignes par une condition peut être effectué avec une syntaxe similaire, ou en utilisant la fonction `subset`. Sélectionnons toutes les fleurs de l'espèce Virginica

```{r message=FALSE, warning=FALSE}
iris_virginica1 <- iris[iris$Species == "virginica",]
iris_virginica2 <- subset(iris, iris$Species == "virginica")

# verifions que les deux dataframe ont le même nombre de lignes
nrow(iris_virginica1) == nrow(iris_virginica2)
```
Vous pouvez utilisez dans les deux cas tous les opérateurs vus dans la section X. L'enjeu est d'arriver à un vecteur booleen final permettant de d'identifier les observations à conserver.

#### Sous sélectionner des colonnes

Nous avons déjà vu comment sélectionner des colonnes en utilisant leur nom ou leur index dans la section X. Ajoutons un cas spécial ici où nous souhaiterions sélectionner des colonnes selon une condition. Par exemple, nous pourrions vouloir ne garder que les colonnes dans lesquelles le mot *Length* apparait. Pour sela, nous auront besoin de la fonction `grepl`, permettant de déterminer si des caractères sont présents dans un chaîne de caractère.

```{r message=FALSE, warning=FALSE}
nom_cols <- names(iris)
print(nom_cols)

test_nom <- grepl("Length",nom_cols, fixed = TRUE)
ok_nom <- nom_cols[test_nom]

iris_2 <- iris[ok_nom]
print(names(iris_2))
```
Il est possible d'obtenir ce résultat en une seule ligne de code, mais elle est un peu moins lisible.

```{r message=FALSE, warning=FALSE}
iris2 <- iris[names(iris)[grepl("Length",nom_cols, fixed = TRUE)]]
```

	
	0.4 importer et manipuler des données
		créer un dataframe
		charger un dataframe
		extraire une colonne ⇒ vecteur
		opérateur mathématique
		subsetting et opérateur logique
		fusion, aggregation, jointure
		créer des nouvelles colonnes (exemple de densité, % etc.)
		subsetting
		
		r language essential (voir chap1 de introductory statistics with R)
	0.5 la syntaxe des graphiques (philosophie de ggplot2)
