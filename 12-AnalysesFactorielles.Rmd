# (PART) Analyses exploratoires multivariées{-} 

# Méthodes factorielles {#chap12}

::: {.bloc_package data-latex=""}
Dans ce chapitre, nous utilisons principalement les *packages* suivants&nbsp;: 

* Pour créer des graphiques&nbsp;:
  - `ggplot2`, le seul, l'unique!
  - `ggpubr` pour combiner des graphiques.
* Pour les analyses factorielles&nbsp;:
  - `FactoMineR` pour réaliser des ACP, AFC et ACM.
  - `factoextra` pour réaliser des graphiques à partir des résultats d'une analyse factorielle.
  - `explor` pour les résultats d'une ACP, AFC ou ACM avec une interface Web interactive.
* Autre *package*&nbsp;:
  - `geocmeans` pour un jeu de données utilisé pour calculer une ACP.
  - `ggplot2`, `ggpubr`, `stringr` et `corrplot` pour réaliser des graphiques personnalisés sur les résultats d'une analyse factorielle.
  - `tmap` et `RColorBrewer` pour cartographier les coordonnées factorielles.
:::

 
## Petit historique {#sect121}

## Analyses de composantes principales (ACP) {#sect122}


### Recherche d'une simplifaication {#sect1221}

### Mise en œuvre dans R {#sect1223}

Plusieurs *packages* permettent de calculer une ACP dans R, notamment `psych` et `FactoMineR`. Ce dernier est certainement le plus abouti. De plus, il permet également de calculer une analyse des correspondances (AFC), une analyse des correspondances multiples (ACM) et une analyse factorielle de données mixtes (AFDM). Nous utilisons donc `FactoMineR` pour mettre en œuvre les trois types de méthodes factorielles abordées dans ce chapitre (ACP, AFC et ACM). Pour l'ACP, nous exploitons un jeu de données issu du *package* `geocmeans` qu'il faut préalablement charger à l'aide des lignes de code suivantes.

```{r echo=TRUE}
library(geocmeans)
data(LyonIris)
Data <- LyonIris@data[c("CODE_IRIS","Lden","NO2","PM25","VegHautPrt",
                        "Pct0_14","Pct_65","Pct_Img",
                        "TxChom1564","Pct_brevet","NivVieMed")]
```


#### Calcul et exploration d'une ACP avec `FactoMineR` {#sect12231}

Pour calculer l'ACP, il suffit d'utiliser la fonction `PCA` de `FactoMineR`, puis la fonction `summary(MonACP)` qui renvoie les résultats de l'ACP pour : 

- Les valeurs propres (section `Eigenvalues`) pour les composantes principales (`Dim.1` à `Dim.n`) avec leur variance expliquée brute (`Variance`), en pourcentage (`% of var.`) et en pourcentage cumulé (`Cumulative % of var.`).
- Les dix premières observations (section `Individuals`) avec les coordonnées factorielles (`Dim.1` à `Dim.n`), les contributions (`ctr`) et les cosinus carrés (`cos2`). Pour accéder aux résultats pour toutes les observations, utilisez les fonctions `res.acp$ind` ou encore `res.acp$ind$coord` (uniquement les coordonnées factorielles), `res.acp$ind$contrib` (uniquement les contributions) et `res.acp$ind$cos2` (uniquement les cosinus carrés).
- Les variables (section `Variables`) avec les coordonnées factorielles (D`im.1` à `Dim.n`), les contributions (`ctr`) et les cosinus carrés (`cos2`).

```{r echo=TRUE}
library(FactoMineR)

##################################################################
##              Version classique avec FactoMineR               ##
##################################################################
# Construction d'une ACP sur les colonnes 2 à 11 du dataframe Data
res.acp <- PCA(Data[,2:11], scale.unit=TRUE, graph=F)
# Affichage les résultats de la fonction PCA
print(res.acp)
# Résumé des résultats (valeurs propres, individus, variables)
summary(res.acp)
```

Avec les fonctions de base avec `barplot` et `plot`, il est possible de construire rapidement des graphiques pour explorer les résultats de l'ACP pour les valeurs propres, les variables et les individus.

```{r echo=TRUE}
# Graphiques pour les variables propres
barplot(res.acp$eig[,1], main="Valeurs propres", names.arg=1:nrow(res.acp$eig))
barplot(res.acp$eig[,2], main="Variance expliquée (%)", names.arg=1:nrow(res.acp$eig))
barplot(res.acp$eig[,3], main="Variance expliquée cumulée (%)", names.arg=1:nrow(res.acp$eig))
# Nuage du points du premier plan factoriel pour les variables et les individus
plot(res.acp, graph.type = "classic", choix="var", axes = 1:2, 
     title = "Premier plan factoriel (variables)")
plot(res.acp, graph.type = "classic", choix="ind", axes = 1:2, 
     title = "Premier plan factoriel (individus)")
```

#### Exploration graphique des résultats de l'ACP avec `factoextra` {#sect12232}

Visuellement, vous avez pu constater que les graphiques ci-dessus (pour les valeurs propres et pour le premier plan factoriel pour les variables et les individus) réalisés avec les fonctions de base `barplot` et `plot` sont peu attrayants. Avec le *package* `factoextra`, quelques lignes de code suffissent pour construire des graphiques bien plus jolis. 

Premièrement, la syntaxe ci-dessous renvoie deux graphiques pour analyser les résultats des valeurs propres (figure \@ref(fig:factoextra1)).

```{r factoextra1, echo=TRUE, fig.align='center', fig.cap="Graphiques pour les valeurs propres avec factoextra", quietly = TRUE, warn.conflicts = TRUE,   message=FALSE, auto_pdf=TRUE, out.width='75%', dev="png", dpi=300}
library(factoextra)
library(ggplot2)
library(ggpubr)

#################################################################
##                 Graphiques avec factoextra                  ##
#################################################################
# Graphiques des variables propres
G1 <- fviz_screeplot(res.acp, choice ="eigenvalue", addlabels = TRUE,
                     x="Composantes",
                     y="Valeur propre",
                    title="")

G2 <- fviz_screeplot(res.acp, choice ="variance", addlabels = TRUE,
                     x="Composantes",
                     y="Pourcentage de la variance expliquée",
                     title="")

ggarrange(G1, G2)
```

Deuxièmement, la syntaxe ci-dessous renvoie trois graphiques pour analyser les contributions de chaque variable aux deux premiers axes de l'ACP (figures \@ref(fig:factoextra2) et \@ref(fig:factoextra3)) et la qualité de représentation des variables sur les trois premiers axes (figure \@ref(fig:factoextra4)), c'est-à-dire la somme des cosinus carrés sur les trois axes retenus.

```{r eval=FALSE, include=TRUE}
# Contributions des variables aux deux premières composantes
fviz_contrib(res.acp, choice = "var", axes = 1, top = 10,
             title = "Contributions des variables à la première composante")
fviz_contrib(res.acp, choice = "var", axes = 2, top = 10,
             title = "Contributions des variables à la première composante")
fviz_cos2(res.acp, choice = "var", axes = 1:3)+
  labs(x="", y="Somme des cosinus carrés sur les 3 axes retenus",
       title ="Qualité de représentation des variables sur les axes retenus de l'ACP")
```


```{r factoextra2, echo=FALSE, fig.align='center', fig.cap="Contributions des variables à la première composante avec factoextra", auto_pdf=TRUE, dev="png", dpi=300, out.width='75%'}
# Contributions des variables aux deux premières composantes
fviz_contrib(res.acp, choice = "var", axes = 1, top = 10,
             title = "Contributions des variables à la première composante")
```

```{r factoextra3, echo=FALSE, fig.align='center', fig.cap="Contributions des variables à la deuxième composante avec factoextra", auto_pdf=TRUE, dev="png", dpi=300, out.width='75%'}
# Contributions des variables aux deux premières composantes
fviz_contrib(res.acp, choice = "var", axes = 2, top = 10,
             title = "Contributions des variables à la première composante")
```

```{r factoextra4, echo=FALSE, fig.align='center', fig.cap="Qualité des variables sur les trois premières composantes avec factoextra", auto_pdf=TRUE, dev="png", dpi=300, out.width='75%'}
fviz_cos2(res.acp, choice = "var", axes = 1:3)+
  labs(x="", y="Somme des cosinus carrés sur les 3 axes retenus",
       title ="Qualité de représentation des variables sur les axes retenus de l'ACP")
```


Troisièmement, le code ci-dessus renvoie un nuage de points pour le premier plan factoriel de l'ACP (axes 1 et 2) pour les variables (figure \@ref(fig:factoextra5)) et les individus (figure \@ref(fig:factoextra6)).

```{r eval=FALSE, include=TRUE}
# Premier plan factoriel pour les variables avec factoextra
fviz_pca_var(res.acp, col.var="steelblue",
             title = "Premier plan factoriel pour les variables")+
  theme_minimal()

fviz_pca_var(res.acp, col.var="contrib",
             title = "Premier plan factoriel pour les variables")+
  scale_color_gradient2(low="#313695", mid="#ffffbf", high="#a50026",
                        midpoint=mean(res.acp$var$contrib[,1]))

# Premier plan factoriel pour les individus avec factoextra
fviz_pca_ind(res.acp, label="none")
fviz_pca_ind(res.acp, col.ind="cos2") +
  scale_color_gradient2(low="blue", mid="white", high="red", midpoint=0.50)
```

```{r factoextra5, echo=FALSE, fig.align='center', fig.cap="Premier plan factoriel pour les variables avec factoextra", auto_pdf=TRUE, dev="png", dpi=300, out.width='100%'}
G1 <- fviz_pca_var(res.acp, col.var="steelblue",
             title = "Premier plan factoriel pour les variables")+
  theme_minimal()

G2 <- fviz_pca_var(res.acp, col.var="contrib",
             title = "Premier plan factoriel pour les variables")+
  scale_color_gradient2(low="#313695", mid="#ffffbf", high="#a50026",
                        midpoint=mean(res.acp$var$contrib[,1]))
ggarrange(G1, G2, ncol=1)
```

```{r factoextra6, echo=FALSE, fig.align='center', fig.cap="Premier plan factoriel pour les individus avec factoextra", auto_pdf=TRUE, dev="png", dpi=300, out.width='75%'}
G1 <- fviz_pca_ind(res.acp, label="none")
G2 <- fviz_pca_ind(res.acp, col.ind="cos2") +
  scale_color_gradient2(low="blue", mid="white", high="red", midpoint=0.50)
ggarrange(G1, G2, ncol=1)
```

#### Personnalisation des graphiques avec les résultats de l'ACP {#sect12233}

Avec un plus peu de code et l'utilisation d'autres *packages* (`ggplot2`, `ggpubr`, `stringr`, `corrplot`), vous pouvez aussi construire des graphiques personnalisés.

Premièrement, la syntaxe ci-dessous permet de réaliser trois graphiques pour analyser les valeurs propres (figure \@ref(fig:acpmesgraphs1)). Notez que, d'un coup d'œil, nous pouvons identifier les composantes principales avec une valeur propre égale ou supérieure à 1. 

```{r eval=FALSE, include=TRUE}
library(ggplot2)
library(ggpubr)
library(stringr)
library(corrplot)

# Calcul de l'ACP
res.acp <- PCA(Data[,2:11], ncp=5, scale.unit=TRUE, graph=F)
print(res.acp)

# Construction d'un dataframe pour les valeurs propres
dfACPvp <- data.frame(res.acp$eig)
names(dfACPvp) <- c("VP","VP_pct","VP_cumupct")
dfACPvp$Composante <- factor(1:nrow(dfACPvp), levels=rev(1:nrow(dfACPvp)))

couleursAxes <- c("steelblue","skyblue2")
vpsup1 <- round(sum(subset(dfACPvp, VP >= 1)$VP),2)
vpsup1cumul <- round(sum(subset(dfACPvp, VP >= 1)$VP_pct),2)

plotVP1 <- ggplot(dfACPvp,aes(x=VP, y=Composante,fill=VP<1))+
  geom_bar(stat="identity", width = .6, alpha=.8, color="black")+
  geom_vline(xintercept=1, linetype="dashed", color = "azure4", size=1)+
  scale_fill_manual(name="Valeur\npropre",values=couleursAxes,labels = c(">= 1","< 1"))+
  labs(x="Valeur propre", y="Composante principale")

plotVP2 <- ggplot(dfACPvp, aes(x=VP_pct, y=Composante,fill=VP<1))+
  geom_bar(stat="identity", width = .6, alpha=.8, color="black")+
  scale_fill_manual(name="Valeur\npropre",values=couleursAxes,labels = c(">= 1","< 1"))+
  theme(legend.position="none")+
  labs(x="Pourcentage de la variance expliquée", y="")

plotVP3 <- ggplot(dfACPvp, aes(x=VP_cumupct, y=Composante,fill=VP<1, group=1))+
  geom_bar(stat="identity", width = .6, alpha=.8, color="black")+
  scale_fill_manual(name="Valeur\npropre",values=couleursAxes,labels = c(">= 1","< 1"))+
  geom_line(colour="brown", linetype="solid", size=.8) +
  geom_point(size=3, shape=21, color="brown", fill="brown")+
  theme(legend.position="none")+
  labs(x="Pourcentage cumulé de la variance expliquée", y="")

annotate_figure(ggarrange(plotVP1, plotVP2, plotVP3, ncol=2),
                text_grob("Analyse des valeurs propres", 
                         color = "black", face = "bold", size = 12),
                bottom = text_grob(
                         paste0("Somme des valeurs propres supérieures à 1 : ", 
                               vpsup1,
                               ".\nPourcentage cumulé des valeurs propres supérieures à 1 : ", 
                                vpsup1cumul, "%."),
                           color = "black", hjust = 1, x = 1, size = 10))
```

```{r acpmesgraphs1, echo=FALSE, fig.align='center', fig.cap="Graphiques personnalisés pour les valeurs propres", auto_pdf=TRUE, dev="png", dpi=300, out.width='75%'}
library(ggplot2)
library(ggpubr)
library(stringr)

# Calcul de l'ACP
res.acp <- PCA(Data[,2:11], ncp=5, scale.unit=TRUE, graph=F)

# Construction d'un dataframe pour les valeurs propres
dfACPvp <- data.frame(res.acp$eig)
names(dfACPvp) <- c("VP","VP_pct","VP_cumupct")
dfACPvp$Composante <- factor(1:nrow(dfACPvp), levels=rev(1:nrow(dfACPvp)))

couleursAxes <- c("steelblue","skyblue2")
vpsup1 <- round(sum(subset(dfACPvp, VP >= 1)$VP),2)
vpsup1cumul <- round(sum(subset(dfACPvp, VP >= 1)$VP_pct),2)

plotVP1 <- ggplot(dfACPvp,aes(x=VP, y=Composante,fill=VP<1))+
  geom_bar(stat="identity", width = .6, alpha=.8, color="black")+
  geom_vline(xintercept=1, linetype="dashed", color = "azure4", size=1)+
  scale_fill_manual(name="Valeur\npropre",values=couleursAxes,labels = c(">= 1","< 1"))+
  labs(x="Valeur propre", y="Composante principale")

plotVP2 <- ggplot(dfACPvp, aes(x=VP_pct, y=Composante,fill=VP<1))+
  geom_bar(stat="identity", width = .6, alpha=.8, color="black")+
  scale_fill_manual(name="Valeur\npropre",values=couleursAxes,labels = c(">= 1","< 1"))+
  theme(legend.position="none")+
  labs(x="Variance expliquée (%)", y="")

plotVP3 <- ggplot(dfACPvp, aes(x=VP_cumupct, y=Composante,fill=VP<1, group=1))+
  geom_bar(stat="identity", width = .6, alpha=.8, color="black")+
  scale_fill_manual(name="Valeur\npropre",values=couleursAxes,labels = c(">= 1","< 1"))+
  geom_line(colour="brown", linetype="solid", size=.8) +
  geom_point(size=3, shape=21, color="brown", fill="brown")+
  theme(legend.position="none")+
  labs(x="Variance expliquée (% cumulé)", y="")

  annotate_figure(ggarrange(plotVP1, plotVP2, plotVP3, ncol=2, nrow=2),
                  text_grob("Analyse des valeurs propres", color = "black", face = "bold", size = 12),
                  bottom = text_grob(
                          paste0("Somme des valeurs propres supérieures à 1 : ", vpsup1,
                                 ".\nPourcentage cumulé des valeurs propres supérieures à 1 : ", vpsup1cumul, "%."),
                           color = "black", hjust = 1, x = 1, size = 10))
```

Deuxièmement, la syntaxe ci-dessous permet de : 

- Construire un *dataframe* avec les résultats des variables.
- Construire des histogrammes avec les coordonnées des variables sur les axes factoriels (figure \@ref(fig:acpmesgraphs2)). Notez que les coordonnées négatives sont indiquées avec des barres bleues et celles négatives avec des barres de couleur saumon.
- Un graphique avec les contributions des variables sur les axes retenus (figure \@ref(fig:acpmesgraphs3)).
- Un graphique avec les cosinus carrés des variables sur les axes retenus (figure \@ref(fig:acpmesgraphs4)). 
- Un histogramme avec la qualité des variables sur les axes retenus (figure \@ref(fig:acpmesgraphs5)), soit la sommation de leurs cosinus carrés sur les axes retenus.


```{r eval=FALSE, include=TRUE}
# Analyses des résultats de L'ACP pour les variables
# ---------------------------------------------------
# Indiquer le nombre d'axes à conserver suite à l'analyse des valeurs propres
nComp <- 3
# Variance expliquée par les axes retenus
vppct <- round(dfACPvp[1:nComp,"VP_pct"],1)
# Dataframe des résultats pour les variables
CoordsVar <- res.acp$var$coord[, 1:nComp]
Cos2Var   <- res.acp$var$cos2[, 1:nComp]
CtrVar   <- res.acp$var$contrib[, 1:nComp]
dfACPVars <- data.frame(Variable =  row.names(res.acp$var$coord[, 1:nComp]),
                        Coord = CoordsVar,
                        Cos2 = Cos2Var,
                        Qualite = rowSums(Cos2Var),
                        Ctr = CtrVar)
row.names(dfACPVars) <- NULL
names(dfACPVars) <- str_replace(names(dfACPVars), ".Dim.", "Comp")
dfACPVars

# Histogrammes pour les coordonnées
couleursCoords <- c("lightsalmon","steelblue")
plotCoordF1 <- ggplot(dfACPVars,
                      aes(y = reorder(Variable, CoordComp1),
                          x = CoordComp1, fill=CoordComp1<0))+
  geom_bar(stat="identity", width = .6, alpha=.8, color="black")+
  geom_vline(xintercept=0, color = "black", size=1)+
  scale_fill_manual(name="Coordonnée",values=couleursCoords,labels = c("Positive","Négative"))+
  labs(x=paste0("Axe 1 (", vppct[1],"%)"), y="Variable")+
  theme(legend.position="none")

plotCoordF2 <- ggplot(dfACPVars,
                      aes(y = reorder(Variable, CoordComp2),
                          x = CoordComp2, fill=CoordComp2<0))+
  geom_bar(stat="identity", width = .6, alpha=.8, color="black")+
  geom_vline(xintercept=0, color = "black", size=1)+
  scale_fill_manual(name="Coordonnée",values=couleursCoords,labels = c("Positive","Négative"))+
  labs(x=paste0("Axe 2 (", vppct[2],"%)"), y="Variable")+
  theme(legend.position="none")

plotCoordF3 <- ggplot(dfACPVars,
                      aes(y = reorder(Variable, CoordComp3),
                          x = CoordComp3, fill=CoordComp3<0))+
  geom_bar(stat="identity", width = .6, alpha=.8, color="black")+
  geom_vline(xintercept=0, color = "black", size=1)+
  scale_fill_manual(name="Coordonnée", values=couleursCoords,labels = c("Positive","Négative"))+
  labs(x=paste0("Axe 3 (", vppct[3],"%)"), y="Variable")

annotate_figure(ggarrange(plotCoordF1, plotCoordF2, plotCoordF3, nrow=nComp),
                text_grob("Coordonnées des variables sur les axes factoriels",
                          color = "black", face = "bold", size = 12))

# Contributions des variables à la formation des axes
couleurs <- colorRampPalette(c("#ffffd4","#993404"))
corrplot(CtrVar, is.corr=FALSE, method ="square", col = couleurs(100), addCoef.col = 1)

# La qualité des variables sur les composantes retenues : cosinus carrés
corrplot(Cos2Var, is.corr=FALSE, method ="square", col = couleurs(100), addCoef.col = 1)

ggplot(dfACPVars)+
  geom_bar(aes(y=reorder(Variable, Qualite), x=Qualite),
            stat="identity", width = .6, alpha=.8, fill="steelblue")+
  labs(x="", y="Somme des cosinus carrés sur les axes retenus",
       title ="Qualité de représentation des variables sur les axes retenus de l'ACP",
       subtitle = paste0("Variance expliquée par les ", nComp, 
                         " composantes : ", sum(vppct), "%"))
```


```{r acpmesgraphs2, echo=FALSE, fig.align='center', fig.cap="histogrammes personnalisés avec les valeurs propres", auto_pdf=TRUE, dev="png", dpi=300, out.width='75%'}
# Indiquer le nombre d'axes à conserver suite à l'analyse des valeurs propres
nComp <- 3
# Variance expliquée par les axes retenus
vppct <- round(dfACPvp[1:nComp,"VP_pct"],1)
# Dataframe des résultats pour les variables
CoordsVar <- res.acp$var$coord[, 1:nComp]
Cos2Var   <- res.acp$var$cos2[, 1:nComp]
CtrVar   <- res.acp$var$contrib[, 1:nComp]
dfACPVars <- data.frame(Variable =  row.names(res.acp$var$coord[, 1:nComp]),
                        Coord = CoordsVar,
                        Cos2 = Cos2Var,
                        Qualite = rowSums(Cos2Var),
                        Ctr = CtrVar)
row.names(dfACPVars) <- NULL
names(dfACPVars) <- str_replace(names(dfACPVars), ".Dim.", "Comp")

# Histogrammes pour les coordonnées
couleursCoords <- c("lightsalmon","steelblue")
plotCoordF1 <- ggplot(dfACPVars,
                      aes(y = reorder(Variable, CoordComp1),
                          x = CoordComp1, fill=CoordComp1<0))+
  geom_bar(stat="identity", width = .6, alpha=.8, color="black")+
  geom_vline(xintercept=0, color = "black", size=1)+
  scale_fill_manual(name="Coordonnée",values=couleursCoords,labels = c("Positive","Négative"))+
  labs(x=paste0("Axe 1 (", vppct[1],"%)"), y="Variable")+
  theme(legend.position="none")

plotCoordF2 <- ggplot(dfACPVars,
                      aes(y = reorder(Variable, CoordComp2),
                          x = CoordComp2, fill=CoordComp2<0))+
  geom_bar(stat="identity", width = .6, alpha=.8, color="black")+
  geom_vline(xintercept=0, color = "black", size=1)+
  scale_fill_manual(name="Coordonnée",values=couleursCoords,labels = c("Positive","Négative"))+
  labs(x=paste0("Axe 2 (", vppct[2],"%)"), y="Variable")+
  theme(legend.position="none")

plotCoordF3 <- ggplot(dfACPVars,
                      aes(y = reorder(Variable, CoordComp3),
                          x = CoordComp3, fill=CoordComp3<0))+
  geom_bar(stat="identity", width = .6, alpha=.8, color="black")+
  geom_vline(xintercept=0, color = "black", size=1)+
  scale_fill_manual(name="Coordonnée", values=couleursCoords,labels = c("Positive","Négative"))+
  labs(x=paste0("Axe 3 (", vppct[3],"%)"), y="Variable")

annotate_figure(ggarrange(plotCoordF1, plotCoordF2, plotCoordF3, nrow = nComp),
                text_grob("Coordonnées des variables sur les axes factorielles",
                          color = "black", face = "bold", size = 12))
```

```{r acpmesgraphs3, echo=FALSE, message=FALSE, fig.align='center', fig.cap="Graphiques personnalisés avec les contributions des variables", auto_pdf=TRUE, dev="png", dpi=300, out.width='75%'}
library(corrplot)
couleurs <- colorRampPalette(c("#ffffd4","#993404"))
corrplot(CtrVar, is.corr=FALSE, method ="square", col = couleurs(100), addCoef.col = 1)
```

```{r acpmesgraphs4, echo=FALSE, fig.align='center', fig.cap="Graphiques personnalisés avec les cosinus carrés des variables", auto_pdf=TRUE, dev="png", dpi=300, out.width='75%'}
corrplot(Cos2Var, is.corr=FALSE, method ="square", col = couleurs(100), addCoef.col = 1)
```

```{r acpmesgraphs5, echo=FALSE, fig.align='center', fig.cap="Graphique personnalisé avec la qualité des variables sur les axes retenus de l'ACP", auto_pdf=TRUE, dev="png", dpi=300, out.width='75%'}
ggplot(dfACPVars)+
  geom_bar(aes(y=reorder(Variable, Qualite), x=Qualite),
            stat="identity", width = .6, alpha=.8, fill="steelblue")+
  labs(x="", y="Somme des cosinus carrés sur les axes retenus",
       title ="Qualité de représentation des variables sur les axes",
       subtitle = paste0("Variance expliquée par les ", nComp, 
                         " composantes : ", sum(vppct), "%"))
```

Troisièmement, lorsque les observations sont des unités spatiales, il convient de cartographier les coordonnées factorielles des individus. Dans le jeu de données utilisé, les observations sont des polygones délimitant les îlots regroupés pour l'information statistique (IRIS) pour l'agglomération de Lyon (France). Nous utilisons les *packages* `tmap` et `RColorBrewer` pour réaliser des cartes choroplèthes avec les coordonnées deux premières composantes (figure \@ref(fig:acpmesgraphs6)).


```{r acpmesgraphs6, echo=TRUE, fig.align='center', fig.cap="Cartographie des coordonnées factorielles des individus", auto_pdf=TRUE, dev="png", dpi=300, out.width='75%'}

library("tmap")
library("RColorBrewer")

# Analyse des résultats de l'ACP pour les individus
# ---------------------------------------------------
# Dataframe des résultats pour les individus
CoordsInd <- res.acp$ind$coord[, 1:nComp]
Cos2Ind   <- res.acp$ind$cos2[, 1:nComp]
CtrInd    <- res.acp$ind$contrib[, 1:nComp]
dfACPInd <- data.frame(Coord = CoordsInd, Cos2 = Cos2Ind, Ctr = CtrInd)
names(dfACPInd) <- str_replace(names(dfACPInd), ".Dim.", "Comp")

# Fusion du tableau original avec les résultats de l'ACP pour les individus
CartoACP <- cbind(LyonIris, dfACPInd)

# Cartographie des coordonnées factorielles pour les individus pour les
# deux premières composantes
Carte1 <- tm_shape(CartoACP) +
          tm_polygons(col = "CoordComp1", style = "cont",
                      midpoint = 0, title = 'Coordonnées')+
          tm_layout(title = paste0("Axe 1 (", vppct[1],"%)"),
             attr.outside = TRUE, frame = FALSE)

Carte2 <- tm_shape(CartoACP) +
          tm_polygons(col = "CoordComp2", style = "cont",
                      midpoint = 0, title = 'Coordonnées')+
  tm_layout(title = paste0("Axe 2 (", vppct[2],"%)"),
             attr.outside = TRUE, frame = FALSE)

tmap_arrange(Carte1, Carte2)
```


::: {.bloc_aller_loin data-latex=""}
**Exploration interactive des résultats d'une ACP avec le _package_ `explor`**. 

Vous aurez compris qu'il ne suffit pas de calculer une ACP, il faut retenir les *n* premiers axes de l'ACP qui nous semblent les plus pertinents, puis les interpréter à la lecture des coordonnées factorielles, les cosinus carrés et les contributions des variables et des individus sur les axes. Il faut donc bien explorer les résultats à l’aide de tableaux et de graphiques! Cela explique que nous vous avons proposé plusieurs graphiques dans les deux sections précédentes (\@ref(sect12212) et \@ref(sect12213)). 
L’exploration des données d’une ACP peut aussi être réalisée avec des graphiques interactifs. Or, un superbe *package* dénommé `explor` (https://juba.github.io/explor/), reposant sur `Shiny` (https://shiny.rstudio.com/), permet d’explorer de manière interactive les résultats de plusieurs méthodes factorielles calculés avec `FactorMinerR`. Pour cela, il vous suffit de lancer les deux lignes de code suivantes :

`library(explor)`

`explor(res.acp)`
:::

## Analyses factorielles de correspondances (AFC)  {#sect123}

## Analyses factorielles de correspondances multiples (AFM)  {#sect124}

## Analyses factorielles de correspondances mixte  {#sect125}
