# Modèles généralisés additifs  {#chap09}

Dans les précédents chapitres, nous avons eu l'occasion d'explorer les modèles de régressions linéaires, puis les modèles généralisés et enfin les modèles généralisés à effet mixte. Dans ce chapitre, nous abordons une nouvelle extension dans le monde des régressions : Les modèles généralisés additifs (ou *Generalized additive model* : GAM). Cette extension a pour but de permettre de modéliser des relations non linéaires entre les variables indépendantes et la variable dépendante.

## Introduction {#sect091}

Pour rappel, la formule décrivant un modèle linéaire généralisé (GLM) assumant une distribution normale et une fonction de lien identitaire est la suivante : 

\footnotesize
\begin{equation}
\begin{aligned}
&Y \sim Normal(\mu,\sigma)\\
&g(\mu) = \beta_0 + \beta X\\
&g(x) = x
\end{aligned}
(\#eq:glm1)
\end{equation}
\normalsize

Les coefficients \beta permettent de quantifier l'effet des variables indépendantes (*X*) sur la moyenne (\mu) de la variable dépendante (*Y*). Un coefficient négatif indique que si la variable X augmente, alors la variable Y tend à diminuer et inversement si le coefficient est positif. L'inconvéniant de cette formulation est que le modèle est seulement capable de capter des relations linéaires entre ces variables, or il existe de nombreuses situations dans lesquelles une variables indépendante aura un lien non-linéaire avec une variable dépendante. Présentons quelques exemples : 

* Si nous mesurons le niveau de bruit émis par une source sonore (variable dépendante) en plusieurs endroits et que nous tentons de prédire l'intensité sonore en fonction de la distance à la source (variable indépendante), nous ne pouvons nous attendre à observer une relation linéaire entre les deux. En effet, le son est une énergie se dispersant selon une sphère dans l'espace et son intensité est inversement proportionnel au carré de la distance avec la source sonore.
* L'évolution de la concentration de la pollution atmosphérique en ville suit généralement des patrons temporels et spatiaux influencés directement par la météorologie et les activités humaines. Ces patrons ne peuvent pas être simplement décrits par un modèle linéaire.
* Donner un autre exemple ?

```{r figgam1, echo=FALSE, fig.align='center', fig.cap="Patron journalier du NO2 et de l'O3 à Paris", message=FALSE, warning=FALSE, auto_pdf=TRUE, out.width='50%'}
library(dplyr)
knitr::include_graphics('images/gam/no2_03_patterns.PNG', dpi = NA)
```

### Non linéarité fonctionnelle

Il existe de nombreuses façon d'introduire des relations non-linéaires dans un modèle. La première et la plus simple à mettre en oeuvre est de transformer la variable indépendante à l'aide d'une fonction inverse, exponentielle, logaritmique ou autre.

Prenons un premier exemple (figure \@ref(fig:figgam2)) univarié avec une variable Y que nous tentons de prédire avec une variable X.

```{r figgam2, echo=FALSE, fig.align='center', fig.cap="Relation non linéaire exponentielle", message=FALSE, warning=FALSE, auto_pdf=TRUE, out.width='50%'}
library(ggplot2)
library(ggpubr)
library(boot)

df <- data.frame(
  x1 = rnorm(1000,0,1),
  x2 = rnorm(1000,10,1),
  x3 = rnorm(1000,0,3),
  x4 = abs(rnorm(1000,0,5))
)

df$y1 <- exp(df$x1) + rnorm(1000,0,2)
df$y2 <- log(df$x2) + rnorm(1000,0,2)
df$y3 <- inv.logit(df$x3) + rnorm(1000,0,0.3)
df$y4 <- sqrt(df$x4) + rnorm(1000,0,0.2)


ggplot(df)+
  geom_point(aes(x = x1, y = y1), size = 0.5) + 
  labs(x = "x", y = "y")  + 
  geom_smooth(aes(x = x1, y = y1),method = "lm",
              se=FALSE, color="blue", formula = y ~ x)+ 
  geom_smooth(aes(x = x1, y = y1),method = "lm",
              se=FALSE, color="red", formula = y ~ exp(x))

```

Si nous ajustons une droite de régression à ces données (en bleu), nous constatons que l'augmentation de X est associée avec une augmentation de Y. Cependant, la droite de régression est très éloignée des données et ne capte qu'une petite partie de la relation. Si l'on regarde attentivement, on peut constater que l'effet de X sur Y augmente de plus en plus rapidement à mesure que X augmente. Cette forme est caractéristique d'une relation exponentielle. Nous pouvons donc transformer la variable X avec la fonction exponentielle pour obtenir un meilleur ajustement (en rouge).

La figure suivante illustre trois autres cas avec les fonctions logarithmique, logistique inverse et racine carrée.

```{r figgam3, echo=FALSE, fig.align='center', fig.cap="Autres Relations non linéaires", message=FALSE, warning=FALSE, auto_pdf=TRUE, out.width='50%'}

P1 <- ggplot(df)+
  geom_point(aes(x = x2, y = y2), size = 0.5) + 
  labs(x = "x", y = "y", subtitle = "fonction logarithmique")  + 
  geom_smooth(aes(x = x2, y = y2),method = "lm",
              se=FALSE, color="blue", formula = y ~ x)+ 
  geom_smooth(aes(x = x2, y = y2),method = "lm",
              se=FALSE, color="red", formula = y ~ log(x))

P2 <- ggplot(df)+
  geom_point(aes(x = x3, y = y3), size = 0.5) + 
  labs(x = "x", y = "y", subtitle = "fonction logistique inverse")  + 
  geom_smooth(aes(x = x3, y = y3),method = "lm",
              se=FALSE, color="blue", formula = y ~ x)+ 
  geom_smooth(aes(x = x3, y = y3),method = "lm",
              se=FALSE, color="red", formula = y ~ inv.logit(x))

P3 <- ggplot(df)+
  geom_point(aes(x = x4, y = y4), size = 0.5) + 
  labs(x = "x", y = "y", subtitle = "fonction racine carrée")  + 
  geom_smooth(aes(x = x4, y = y4),method = "lm",
              se=FALSE, color="blue", formula = y ~ x)+ 
  geom_smooth(aes(x = x4, y = y4),method = "lm",
              se=FALSE, color="red", formula = y ~ sqrt(x))

ggarrange(P1,P2,P3, ncol = 2, nrow = 2)

```

Cette approche peut donner des résultats intéressants si vous disposez d'une bonne justification théorique sur la forme attendue de la relation entre X et Y. Il existe également de nombreux cas de figure dans lesquels aucune fonction ne donne de résultats pertinents. Prenons ici un nouveau cas avec la figure \@ref(fig:figgam4)).

```{r figgam4, echo=FALSE, fig.align='center', fig.cap="Relation non linéaire plus complexe", message=FALSE, warning=FALSE, auto_pdf=TRUE, out.width='70%'}

library(mgcv)
dataset <- gamSim(eg=1,n=400,dist="normal",scale=1,verbose=F)

ggplot(dataset) + 
  geom_point(aes(y = y, x = x2), size = 1) + 
  geom_smooth(aes(x = x2, y = y, color = "lineaire"),method = "lm",
              se=FALSE, formula = y ~ x, size = 1.3) + 
  geom_smooth(aes(x = x2, y = y, color = "logarithme"),method = "lm",
              se=FALSE, formula = y ~ log(x), size = 1.3) +
  geom_smooth(aes(x = x2, y = y, color = "racine carrée"),method = "lm",
              se=FALSE, formula = y ~ sqrt(x), size = 1.3) + 
  scale_color_manual(values = c("lineaire" = "#0077b6",
                                "logarithme" = "#e63946",
                                "racine carrée" = "#2a9d8f"))

```

Nous constatons facilement qu'aucune des fonctions proposées n'est capable de capter la relation entre nos variables X et Y. Cette dernière est complexe et nous devons utiliser une autre stratégie pour la modéliser. 

### Non linéarité avec des polynomiales

Nous avions vu dans le premier chapitre sur la régression simple (REF) qu'il est possible d'utiliser des polynomiales. Pour rappel, il s'agit simplement d'ajouter à un modèle la variable X à différents exposants. Chaque exposant supplémentaire (chaque degré) permet au modèle d'ajuster une relation plus complexe. Rien de tel à nouveau qu'un graphique (figure : \@ref(fig:figgam5)) pour l'illustrer.

```{r figgam5, echo=FALSE, fig.align='center', fig.cap="Visualisation de plusieurs polynomiales", message=FALSE, warning=FALSE, auto_pdf=TRUE, out.width='70%'}

p1 <- ggplot(dataset) + 
  geom_point(aes(y = y, x = x2), size = 1) + 
  geom_smooth(aes(x = x2, y = y), color = "blue" ,method = "lm",
              se=FALSE, formula = y ~ x + I(x**2), size = 1.3) + 
  labs(subtitle = "polynomiale de degré 2", x = "x", y = "y")
  
p2 <- ggplot(dataset) + 
  geom_point(aes(y = y, x = x2), size = 1) + 
  geom_smooth(aes(x = x2, y = y), color = "blue" ,method = "lm",
              se=FALSE, formula = y ~ x + I(x**2) + I(x**3), size = 1.3) + 
  labs(subtitle = "polynomiale de degré 3", x = "x", y = "y")

p3 <- ggplot(dataset) + 
  geom_point(aes(y = y, x = x2), size = 1) + 
  geom_smooth(aes(x = x2, y = y), color = "blue" ,method = "lm",
              se=FALSE, formula = y ~ x + I(x**2) + I(x**3) + I(x**4), size = 1.3) + 
  labs(subtitle = "polynomiale de degré 4", x = "x", y = "y")

p4 <- ggplot(dataset) + 
  geom_point(aes(y = y, x = x2), size = 1) + 
  geom_smooth(aes(x = x2, y = y), color = "blue" ,method = "lm",
              se=FALSE, formula = y ~ x + I(x**2) + I(x**3) + I(x**4)+ I(x**5), size = 1.3) + 
  labs(subtitle = "polynomiale de degré 5", x = "x", y = "y")

ggarrange(p1,p2,p3,p4, ncol = 2, nrow = 2)
```

L'enjeu est de sélectionner le bon nombre de degrés de la polynomiale pour le modèle. Chaque degré supplémentaire constitue une nouvelle variable dans le modèle et donc un paramètre supplémentaire. Un trop faible nombre de degrés produit des courbes trop simplistes alors qu'un nombre trop élevé conduit à un surajustement (*overfitting* en anglais) du modèle. La figure \@ref(fig:figgam6) illustre ces deux extrèmes.

```{r figgam6, echo=FALSE, fig.align='center', fig.cap="Sur et sous-ajustement d'une polynomiale", message=FALSE, warning=FALSE, auto_pdf=TRUE, out.width='70%'}
ggplot(dataset) + 
  geom_point(aes(y = y, x = x2), size = 1) + 
  geom_smooth(aes(x = x2, y = y), color = "blue" ,method = "lm",
              se=FALSE, formula = y ~ x + I(x**2), size = 1.3) +
  geom_smooth(aes(x = x2, y = y), color = "red" ,method = "lm",
              se=FALSE, formula = y ~ x + poly(x,degree = 12), size = 1.3) + 
  labs(subtitle = "polynomiales de degrés 2 et 12", x = "x", y = "y")
```

Un des problèmes inhérents à l'approche des polynomiales est la difficulté d'interprétation. En effet, les coefficients ne sont pas directement interprétables et seule la figure représentant les prédictions du modèle permet de se faire une idée de l'impact de la variable X sur la variable Y.

### Non linéarité par segments

Un compromis intéressant offrant une interprétation simple et une relation potentiellement complexe est de découper la variable X en segments et d'ajuster un coefficient différent pour chaque segment. On obtient ainsi une ligne brisée et des coefficients faciles à interpréter. 
```{r figgam7, echo=FALSE, fig.align='center', fig.cap="Régression par segment", message=FALSE, warning=FALSE, auto_pdf=TRUE, out.width='70%'}
library(segmented)

model <- lm(y ~ x2, data = dataset)
o <- segmented(model, seg.Z = ~x2, psi = list(x2 = c(0.25,0.5)),
  control = seg.control(display = FALSE)
)
dataset$fit <- broken.line(o)$fit

ggplot(dataset) + 
  geom_point(aes(y = y, x = x2), size = 1) + 
  geom_line(aes(x = x2, y = fit), color = 'blue', size = 1)
```
L'enjeu est alors de choisir le nombre de découpages, ainsi que la localisation des points de rupture. L'inconvéniant de cette approche est que dans la réalité, très peu de phénomènes sont marqués par des ruptures nettes.

Dans notre exemple, nous avons divisé notre variable X en trois segments, $k_1$, $k_2$ et $k_3$, définis respectivement sur [0;0.22], [0.22;0.41] et [0.41;1].  Concrètement, cela revient à diviser la variable X en trois nouvelles variables $X_{k1}$, $X_{k2}$, et $X_{k3}$. Les valeurs de $X_{k}$ sont égales à X si X se trouve dans l'interval propre à *k*, et 0 autrement.



### Non linéarité avec des splines

La dernière approche et probablement la plus flexible est d'utiliser ce que l'on appelle une *spline* pour capter des relations non-linéaire. Une spline est une fonction créant des variables supplémentaires à partir d'une variable X et d'une fonction de base. Ces variables supplémentaires appelées bases (*basis* en anglais) sont ajoutées au modèle, et la sommation de leurs valeurs et coefficients permet de capter les relations non linéaires entre une variable dépendante et une variables indépendante. Le nombre de base, ainsi que leur localisation permettent de contrôler la complexité de la fonction non linéaire. On appelle ces paramètres des noeuds.

Prenons un premier exemple simple avec une fonction de base triangulaire (*tent basis* en anglais). Nous allons créer ici une spline avec 7 noeuds équitablement répartis sur notre variable X et représenter les septs fonctions de bases qui en résultent.

```{r figgam8, echo=FALSE, fig.align='center', fig.cap="Bases de la spline triangulaire", message=FALSE, warning=FALSE, auto_pdf=TRUE, out.width='70%'}
library(splines)

basis <- bs(dataset$x2, df = 7, degre = 1)
df <- data.frame(basis)
df$X <- dataset$x2
df <- reshape2::melt(df, id.vars = "X")

ggplot() + 
  geom_point(aes(y = y, x = x2), size = 1, data = dataset) + 
  geom_line(aes(x = X, y = value, color = variable), size = 1, data = df) + theme(legend.position = "none") 
```

En ajoutant ces fonctions de base dans notre modèle de régression, nous pouvons ajuster un coefficient pour chacune. Nous pouvons le représenter ici en multipliant ces bases par les coefficients obtenus avec une simple régression linéaire.

```{r figgam9, echo=FALSE, fig.align='center', fig.cap="Spline triangulaire multipliée par ces coefficients", message=FALSE, warning=FALSE, auto_pdf=TRUE, out.width='70%'}

basis <- bs(dataset$x2, df = 7, degre = 1)
model <- lm(y ~ basis, data = dataset)
coefs <- coefficients(model)[2:length(coefficients(model))]

prodbase <- sweep(basis, MARGIN = 2, coefs, `*`)

df <- data.frame(prodbase)
df$X <- dataset$x2
df <- reshape2::melt(df, id.vars = "X")

ggplot() + 
  geom_point(aes(y = y, x = x2), size = 1, data = dataset) + 
  geom_line(aes(x = X, y = value, color = variable), size = 1, data = df) + theme(legend.position = "none") 
```

On remarque ainsi que les bases correspondant à des valeurs plus fortes de Y ont reçu des coefficients plus grands. Pour reconstituer la fonction non-linéaire entre X et Y, il suffit d'additionner ces bases multipliées par leurs coefficients.

```{r figgam10, echo=FALSE, fig.align='center', fig.cap="Spline triangulaire", message=FALSE, warning=FALSE, auto_pdf=TRUE, out.width='70%'}

basis <- bs(dataset$x2, df = 7, degre = 1)
model <- lm(y ~ basis, data = dataset)
coefs <- coefficients(model)[2:length(coefficients(model))]

prodbase <- sweep(basis, MARGIN = 2, coefs, `*`)
total <- rowSums(prodbase) + coefficients(model)[1]

df <- data.frame(prodbase)
df$X <- dataset$x2
df <- reshape2::melt(df, id.vars = "X")
df$total <- total

ggplot() + 
  geom_point(aes(y = y, x = x2), size = 1, data = dataset) + 
  geom_line(aes(x = X, y = value, group = variable), color = "grey", linetype="dashed", size = 1, data = df) +
  geom_line(aes(x = X, y = total), color = "blue", size = 1, data = df)+
  theme(legend.position = "none") 
```

La fonction de base triangulaire est intéressante pour présenter la logique qui sous tend les splines, mais elle est rarement utilisée en pratique. On lui préfère généralement d'autre formes donnant des résultats plus lisses comme les B-spline quadratique, B-spline cubiques, M-spline, Duchon spline etc.

```{r figgam10, echo=FALSE, fig.align='center', fig.cap="B-spline", message=FALSE, warning=FALSE, auto_pdf=TRUE, out.width='70%'}
library(mgcv)

## squared spline
basis <- bSpline(dataset$x2, df = 7, degre = 2)
model <- lm(y ~ basis, data = dataset)
coefs <- coefficients(model)[2:length(coefficients(model))]

prodbase <- sweep(basis, MARGIN = 2, coefs, `*`)
total <- rowSums(prodbase) + coefficients(model)[1]

df <- data.frame(prodbase)
df$X <- dataset$x2
df <- reshape2::melt(df, id.vars = "X")
df$total <- total

P1 <- ggplot() + 
  geom_point(aes(y = y, x = x2), size = 1, data = dataset) + 
  geom_line(aes(x = X, y = value, group = variable), color = "grey", linetype="dashed", size = 1, data = df) +
  geom_line(aes(x = X, y = total), color = "blue", size = 1, data = df)+
  theme(legend.position = "none") + 
  labs(subtitle = "B-spline quadratique")+ 
  ylim(0,20)


## cubic spline
basis <- bSpline(dataset$x2, df = 7, degre = 3)
model <- lm(y ~ basis, data = dataset)
coefs <- coefficients(model)[2:length(coefficients(model))]

prodbase <- sweep(basis, MARGIN = 2, coefs, `*`)
total <- rowSums(prodbase) + coefficients(model)[1]

df <- data.frame(prodbase)
df$X <- dataset$x2
df <- reshape2::melt(df, id.vars = "X")
df$total <- total

P2 <- ggplot() + 
  geom_point(aes(y = y, x = x2), size = 1, data = dataset) + 
  geom_line(aes(x = X, y = value, group = variable), color = "grey", linetype="dashed", size = 1, data = df) +
  geom_line(aes(x = X, y = total), color = "blue", size = 1, data = df)+
  theme(legend.position = "none") + 
  labs(subtitle = "B-spline cubique")+ 
  ylim(0,20)

## M-spline
basis <- mSpline(dataset$x2, df = 7, degre = 2)
model <- lm(y ~ basis, data = dataset)
coefs <- coefficients(model)[2:length(coefficients(model))]

prodbase <- sweep(basis, MARGIN = 2, coefs, `*`)
total <- rowSums(prodbase) + coefficients(model)[1]

df <- data.frame(prodbase)
df$X <- dataset$x2
df <- reshape2::melt(df, id.vars = "X")
df$total <- total

P3 <- ggplot() + 
  geom_point(aes(y = y, x = x2), size = 1, data = dataset) + 
  geom_line(aes(x = X, y = value, group = variable), color = "grey", linetype="dashed", size = 1, data = df) +
  geom_line(aes(x = X, y = total), color = "blue", size = 1, data = df)+
  theme(legend.position = "none") + 
  labs(subtitle = "M-spline")+ 
  ylim(0,20)


## Duchon spline
smoother <- smoothCon(s(x2, bs="ds", k = 7), data = dataset, absorb.cons = T)
basis <- smoother[[1]]$X
model <- lm(y ~ basis, data = dataset)
coefs <- coefficients(model)[2:length(coefficients(model))]

prodbase <- sweep(basis, MARGIN = 2, coefs, `*`)
total <- rowSums(prodbase) + coefficients(model)[1]

df <- data.frame(prodbase)
df$X <- dataset$x2
df <- reshape2::melt(df, id.vars = "X")
df$total <- total

P4 <- ggplot() + 
  geom_point(aes(y = y, x = x2), size = 1, data = dataset) + 
  geom_line(aes(x = X, y = value, group = variable), color = "grey", linetype="dashed", size = 1, data = df) +
  geom_line(aes(x = X, y = total), color = "blue", size = 1, data = df)+
  theme(legend.position = "none") + 
  labs(subtitle = "Duchon-spline") + 
  ylim(0,20)

ggarrange(P1,P2,P3,P4, ncol = 2, nrow = 2)
```

Les approches que nous venons de décrire sont regroupées sous l'appelation de modèles additifs. Dans les prochaines sous-sections, nous nous concentrons davantage sur les splines du fait de leur plus grande flexibilité.

## Choix du nombre de noeuds, sur interprétation et sous interprétation

En plus des options que nous avons pu voir précédemment, il est possible de capter une relation non linéaire en utilisant ce que l'on appelle une *spline*.

## Extensions des GAM {#sect092}

### GAMM {#sect0921}
### GAMMAR {#sect0922}
